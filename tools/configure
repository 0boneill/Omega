#!/usr/bin/env python

import os
import shutil
import sys

_CIMEROOT = os.environ.get("CIMEROOT")
if _CIMEROOT is None:
    raise SystemExit("ERROR: must set CIMEROOT environment variable")

_LIBDIR = os.path.join(_CIMEROOT, "scripts", "Tools")
sys.path.append(_LIBDIR)

from standard_script_setup import *
from CIME.macros import MacroMaker
from CIME.utils import expect
from CIME.XML.env_mach_specific import EnvMachSpecific
from CIME.XML.machines import Machines

logger = logging.getLogger(__name__)

def parse_command_line(args):
    """Command line argument parser for configure."""
    description = """This script writes CIME build information to a directory.

The pieces of information that will be written include:

1. Machine-specific build settings (i.e. the "Macros" file).
2. File-specific build settings (i.e. "Depends" files).
3. Environment variable loads (i.e. the env_mach_specific file).
"""
    parser = argparse.ArgumentParser(description=description)
    CIME.utils.setup_standard_logging_options(parser)

    parser.add_argument("--machine",
                        help="The machine to create build information for.")
    parser.add_argument("--machines-dir",
                        help="The machines directory to take build information "
                        "from. Overrides the CIME_MODEL environment variable, "
                        "and must be specified if that variable is not set.")
    parser.add_argument("--macros-format", action='append',
                        choices=['Makefile', 'CMake'],
                        help="The format of Macros file to generate. If "
                        "'Makefile' is passed in, a file called 'Macros.make' "
                        "is generated. If 'CMake' is passed in, a file called "
                        "'Macros.cmake' is generated. This option can be "
                        "specified multiple times to generate multiple files. "
                        "If not used at all, Macros generation is skipped. "
                        "Note that Depends files are currently always in "
                        "Makefile format, regardless of this option.")
    parser.add_argument("--output-dir", default=os.getcwd(),
                        help="The directory to write files to. If not "
                        "specified, defaults to the current working directory.")
    parser.add_argument("--shell-opts",
                        help="Specification of the build configuration to "
                        "generate env_mach_specific shell scripts for. This "
                        "should be of the form COMPILER,MPILIB,DEBUG. "
                        "For example, 'intel,mpich2,true' is a valid setting "
                        "for this option, as long as ICC and MPICH2 are "
                        "available on this machine. If this option is not "
                        "specified, only the XML file is generated (mainly for "
                        "documentation/testing), with no shell scripts.")

    args = parser.parse_args()
    CIME.utils.handle_standard_logging_options(args)

    opts = {}
    if args.machines_dir is not None:
        machines_file = os.path.join(args.machines_dir, "config_machines.xml")
        opts['machobj'] = Machines(infile=machines_file, machine=args.machine)
    else:
        if os.environ.get('CIME_MODEL') is not None:
            opts['machobj'] = Machines(machine=args.machine)
        else:
            expect(False, "Either --mach-dir or the CIME_MODEL environment "
                   "variable must be specified!")

    if args.macros_format is None:
        opts['macros_format'] = []
    else:
        opts['macros_format'] = args.macros_format

    expect(os.path.isdir(args.output_dir),
           "Output directory '%s' does not exist." % args.output_dir)

    opts['output_dir'] = args.output_dir

    if args.shell_opts is not None:
        compiler, mpilib, debug = tuple(args.shell_opts.split(","))
        expect(opts['machobj'].is_valid_compiler(compiler),
               "Invalid compiler vender passed in --shell-opts: %s" % compiler)
        opts['compiler'] = compiler
        expect(opts['machobj'].is_valid_MPIlib(mpilib),
               "Invalid MPI library name passed in --shell-opts: %s" % mpilib)
        opts['mpilib'] = mpilib
        debug_normed = debug.lower()
        if debug_normed == "true":
            opts['debug'] = True
        elif debug_normed == "false":
            opts['debug'] = False
        else:
            expect(False,
                   "Invalid DEBUG value passed in --shell-opts "
                   "(must be true or false): %s" % debug)

    return opts

def _main():
    opts = parse_command_line(sys.argv)
    machobj = opts['machobj']
    output_dir = opts['output_dir']

    # Macros generation.
    suffixes = {'Makefile': '.make', 'CMake': '.cmake'}
    macro_maker = MacroMaker(machobj)
    build_file_name = os.path.join(machobj.machines_dir, "config_build.xml")
    for form in opts['macros_format']:
        out_file_name = os.path.join(output_dir,
                                     "Macros"+suffixes[form])
        with open(out_file_name, "w") as macros_file:
            macro_maker.write_macros(form, build_file_name, macros_file)

    # Depends file copy.
    mach_depends = os.path.join(machobj.machines_dir,
                                "Depends."+machobj.get_machine_name())
    if os.path.isfile(mach_depends):
        shutil.copy(mach_depends, output_dir)
    compilers = machobj.get_value("COMPILERS").split(",")
    for compiler in compilers:
        compiler_depends = os.path.join(machobj.machines_dir,
                                        "Depends."+compiler)
        if os.path.isfile(compiler_depends):
            shutil.copy(compiler_depends, output_dir)

    # env_mach_specific generation.
    ems_file = EnvMachSpecific(output_dir)
    ems_file.populate(machobj)
    ems_file.write()
    if 'compiler' in opts:
        for shell in ('sh', 'csh'):
            ems_file.make_env_mach_specific_file(opts['compiler'], opts['debug'],
                                                 opts['mpilib'], shell)


if __name__ == "__main__":
    _main()
