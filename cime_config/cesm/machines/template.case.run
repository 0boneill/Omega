#!/usr/bin/env python2

"""
script to create a case run script
"""

import sys, os, calendar, shutil, time

workdir = os.environ.get("PBS_O_WORKDIR")
if workdir is not None:
    os.chdir(workdir)

_CIMEROOT = os.environ.get("CIMEROOT")
if _CIMEROOT is None:
    raise exc_type("ERROR: must set CIMEROOT environment variable")

_LIBDIR = os.path.join(_CIMEROOT, "scripts", "Tools")
sys.path.append(_LIBDIR)

from standard_script_setup          import *
from CIME.XML.standard_module_setup import *
from CIME.case                      import Case
from CIME.utils                     import expect, get_model, run_cmd
from CIME.env_module                import EnvModule
from CIME.utils                     import expect, get_utc_timestamp
from CIME.check_lockedfiles         import check_lockedfiles
from CIME.preview_namelists         import preview_namelists

logger = logging.getLogger(__name__)

#---------------------------------
# Batch system directives 
#---------------------------------
{{ batchdirectives }}

#---------------------------------
# PE Layout Documentation:
#---------------------------------
{{ pedocumentation }}

###############################################################################
def parse_command_line(args):
###############################################################################

    parser = argparse.ArgumentParser()
    CIME.utils.setup_standard_logging_options(parser)
    args = parser.parse_args()
    CIME.utils.handle_standard_logging_options(args)

###############################################################################
def doPreRunChecks(case):
###############################################################################

    # Pre run initialization code..
    model          = CIME.utils.get_model()
    caseroot       = case.get_value("CASEROOT")
    cimeroot       = case.get_value("CIMEROOT")
    din_loc_root   = case.get_value("DIN_LOC_ROOT")
    compiler       = case.get_value("COMPILER")
    debug          = case.get_value("DEBUG")
    mach           = case.get_value("MACH")
    lbquery        = case.get_value("LBUQERY")
    batchsubmit    = case.get_value("BATCHSUBMIT")
    mpilib         = case.get_value("MPILIB")
    rundir         = case.get_value("RUNDIR")
    build_complete = case.get_value("BUILD_COMPLETE")

    # check for locked files.
    check_lockedfiles()
    logger.debug("check_lockedfiles OK")

    # load the module environment...
    env_module = EnvModule(mach, compiler, cimeroot, caseroot, mpilib, debug)
    env_module.load_env_for_case()

    # currently need to set mpilib as an environment variable- otherwise
    # the model dies at runtime 
    # FIXME: is there a way to remove this requirement?
    if mpilib == "mpi-serial":
        del os.environ["MP_MPILIB"]
    else:
        os.environ["MPILIB"] = mpilib

    expect (build_complete,
            "BUILD_COMPLETE is not true\nPlease rebuild the model interactively")
    logger.debug("build complete is %s " %build_complete)

    if batchsubmit is None or len(batchsubmit) == 0:
        os.environ["LBQUERY"] = "FALSE"
        os.environ["BATCHQUERY"] = "undefined"
    elif batchsubmit == 'UNSET':
        os.environ["LBQUERY"] = "FALSE"
        os.environ["BATCHQUERY"] = "undefined"
    else:
        os.environ["LBQUERY"] = "TRUE"
    
    # Create the timing directories, optionally cleaning them if needed.
    try:
        os.stat(rundir)
    except:
        os.mkdir(rundir)       

    if os.path.isdir(rundir + '/timing'):
        shutil.rmtree(rundir + '/timing')
    os.makedirs(rundir + '/timing/checkpoints')

    appendCaseStatus(caseroot, "%s Run started \n" %(time.strftime("%Y-%m-%d %H:%M:%S")))

    preview_namelists()

    logger.info( "-------------------------------------------------------------------------")
    logger.info( " - To prestage required restarts, untar a restart.tar file into %s" %(rundir))
    logger.info( " - Case input data directory (DIN_LOC_ROOT) is %s " %(din_loc_root))
    logger.info( " - Checking for required input datasets in DIN_LOC_ROOT")
    logger.info( "-------------------------------------------------------------------------")

###############################################################################
def runModel(case):
###############################################################################

    # Set OMP_NUM_THREADS
    num_threads = {{ thread_count }}
    os.environ["OMP_NUM_THREADS"] = str(num_threads)

    # Run the model
    cmd = ("sleep 10")
    run_cmd(cmd)

    logger.info("%s MODEL EXECUTION BEGINS HERE" %(time.strftime("%Y-%m-%d %H:M:S")))

    {{ mpirun }}
    cmd = case.get_resolved_value(cmd)

    logger.debug("run command is %s " %cmd)
    rundir = case.get_value("RUNDIR")
    run_cmd(cmd, from_dir=rundir) 
    logger.info( "%s MODEL EXECUTION HAS FINISHED" %(time.strftime("%Y-%m-%d %H:M:S")))

###############################################################################
def checkRunStatus(case, lid):
###############################################################################

    caseroot = case.get_value("CASEROOT")
    rundir   = case.get_value("RUNDIR")
    model    = case.get_value("MODEL")

    # find the last model.log and cpl.log
    model_logfile = os.path.join(rundir,model + ".log." + lid)
    cpl_logfile   = os.path.join(rundir,"cpl" + ".log." + lid)

    if not os.path.isfile(model_logfile):
        msg = "%s Model did not complete, no model log file %s \n" %(time.strftime("%Y-%m-%d %H:%M:%S"), model_logfile)
        appendCaseStatus(caseroot,msg)
        expect(False, msg) 
    elif not os.path.isfile(cpl_logfile):
        msg = "%s Model did not complete, no cpl log file %s \n" %(time.strftime("%Y-%m-%d %H:%M:%S"), cpl_logfile) 
        appendCaseStatus(caseroot, msg)
        expect(False, msg) 
    elif os.stat(model_logfile).st_size == 0:
        msg = " %s Run FAILED " %time.strftime("%Y-%m-%d %H:%M:%S")
        appendCaseStatus(caseroot, msg)
        expect (False, msg)
    else:
        if 'SUCCESSFUL TERMINATION' in open(cpl_logfile).read():
            msg = "%s run SUCCESSFUL" %time.strftime("%Y-%m-%d %H:%M:%S")
            appendCaseStatus(caseroot, msg )
        else:
            msg = "%s Model did not complete - see %s \n " %(time.strftime("%Y-%m-%d %H:%M:%S"), cpl_logfile)
            appendCaseStatus(caseroot, msg)
            expect (False, msg)

###############################################################################
def getTimings(case, lid)
###############################################################################

    check_timing = case.get_value("CHECK_TIMING")
    save_timing  = case.get_value("SAVE_TIMING")
    rundir       = case.get_value("RUNDIR")

    if check_timing:
        timingDir = os.path.join(caseroot,"timing")
        if not os.path.isdir(timingDir):
            os.makedirs(timingDir)

        logger.info("Running timing script %s " %(os.path.join(caseroot, "Tools/getTiming")))
        cmd = "%s -lid %s " %(os.path.join(caseroot,"Tools/getTiming"), lid)
        run_cmd(cmd) 

        logger.info( "gzipping timing stats.." )
        timingfile = model + "_timing_stats." + lid
        print "DEBUG: timing file is ",timingfile
        cmd = gzip  + (os.path.join(caseroot,timingfile))
        run_cmd(cmd) 

    # Save the timing files if desired
    if save_timing:
        shutil.move(os.path.join(rundir,"timing"), 
                    os.path.join(rundir,"timing."+lid))



###############################################################################
def disposeLog(case, lid):
###############################################################################

    caseroot = case.get_value("CASEROOT")
    rundir   = case.get_value("RUNDIR")
    logdir   = case.get_value("LOGDIR")
    lid      = os.environ["LID"]
    logger.debug("lid %s" %(lid))

    if logdir is not None and len(logdir) > 0:
        if not os.path.isdir(logdir):
            os.makedirs(logdir)

	#FIXME - get rid of this list
        comps = ("atm", "glc", "ice", "lnd", "ocn", "rof", "wav", "cpl", "cesm", "esp") 

        for comp in comps:
            logfile = os.path.join(comp + '.log.' + lid)
            if os.path.isfile(os.path.join(rundir,logfile)):
                cmd = "gzip " + logfile
                run_cmd(cmd, from_dir=rundir)
                logfile = logfile + ".gz"
                shutil.copy(os.path.join(rundir,logfile), 
                            os.path.join(caseroot,logdir,logfile))

###############################################################################
def resubmitCheck(case):
###############################################################################

    # check to see if we need to do resubmission from this particular job,
    # Note that Mira requires special logic

    caseroot     = case.get_value("CASEROOT")
    dout_s       = case.get_value("DOUT_S")
    mach         = case.get_value("MACH")
    testcase     = case.get_value("TESTCASE")
    resubmit_num = int(case.get_value("RESUBMIT"))
    
    # If dout_s is True than short-term archiving handles the resubmit
    # that is not the case on Mira
    resubmit = False
    if not dout_s and resubmit_num > 0: 
        resubmit = True
    elif dout_s and mach == 'mira':
        resubmit = True

    if resubmit:
	cmd = os.path.join(caseroot,"case.submit") + "-resubmit -scriptname case."
        if testcase is not None and testcase == 'ERR':
	   cmd = cmd + "test"
        else:
	   cmd = cmd + "run"
        logger.debug( "running resubmit check %s " %cmd)
        rc, output, error = run_cmd(cmd, ok_to_fail=True, from_dir=caseroot)
        if rc != 0:
            logger.warn("could not run case submit script, rc=%s, output=%s, error=%s" %(rc,output,error))

###############################################################################
def DoDataAssimilation(case, da_script, lid):
###############################################################################

    cmd = "da_script 1> da.log.%s 2>&1" %(lid)
    run_cmd(cmd)
    cmd = "sleep(1)"
    run_cmd(cmd)
    disposeLog(case, 'da', lid)

###############################################################################
def appendCaseStatus(caseroot, msg):
###############################################################################

    with open(os.path.join(caseroot,"CaseStatus"), "a") as fd:
        fd.write(msg)

###############################################################################
def _main_func():
###############################################################################

    # Set up the run, run the model, do the postrun steps

    parse_command_line(sys.argv)

    case = Case()

    run_with_submit = case.get_value("RUN_WITH_SUBMIT")
    expect (run_with_submit,
             "You are not calling the run script via the submit script. "
             "As a result, short-term archiving will not be called automatically."
             "Please submit your run by calling ./case.submit")

    data_assimilation        = case.get_value("DATA_ASSIMILATION")
    data_assimilation_cycles = case.get_value("DATA_ASSIMILATION_CYCLES")
    data_assimilation_script = case.get_value("DATA_ASSIMILATION_SCRIPT")

    # Now set up the LID 
    os.environ["LID"] = time.strftime("%y%m%d-%H%M%S")

    for cycle in range(0,data_assimilation_cycles):
        doPreRunChecks(case)
        runModel(case)
        checkRunStatus(case, lid) # Check run status
        disposeLog(case, lid)     # Copy log files back to caseroot
        getTimings(case, lid)     # Run the getTiming script
        if data_assimilation:
            DoDataAssimilation(case, data_assimilation_script, lid)

    resubmitCheck(case)

###############################################################################

if __name__ == "__main__":
    _main_func()
