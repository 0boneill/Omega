module test_vertical_gradient_calculator_2nd_order
  
  ! Tests of vertical_gradient_calculator_2nd_order
  
  use pfunit_mod
  use vertical_gradient_calculator_base
  use vertical_gradient_calculator_2nd_order
  use shr_kind_mod, only : r8 => shr_kind_r8
  use mct_mod, only : mct_aVect, mct_aVect_clean
  use mct_wrapper_mod, only : mct_init, mct_clean
  use avect_wrapper_mod
  
  implicit none

  real(r8), parameter :: tol = 1.e-13_r8
  
  @TestCase
  type, extends(TestCase) :: TestVertGradCalc2ndOrder
     type(mct_aVect) :: av
   contains
     procedure :: setUp
     procedure :: tearDown
     procedure :: create_av
     procedure :: create_calculator
     procedure :: calculateAndVerifyGradient_1point_ECmid
  end type TestVertGradCalc2ndOrder
  
contains
  
  subroutine setUp(this)
    class(TestVertGradCalc2ndOrder), intent(inout) :: this

    call mct_init()
    
  end subroutine setUp
  
  subroutine tearDown(this)
    class(TestVertGradCalc2ndOrder), intent(inout) :: this

    call mct_aVect_clean(this%av)
    call mct_clean()
  end subroutine tearDown

  function two_digit_string(val)
    ! Converts val to a two-digit string
    character(len=2) :: two_digit_string
    integer, intent(in) :: val

    write(two_digit_string, '(i2.2)') val
  end function two_digit_string

  subroutine create_av(this, topo, data, toponame, dataname)
    ! Creates the attribute vector in 'this'
    class(TestVertGradCalc2ndOrder), intent(inout) :: this
    real(r8), intent(in) :: topo(:,:)  ! topo(i,j) is point i, elevation class j
    real(r8), intent(in) :: data(:,:)  ! data(i,j) is point i, elevation class j
    character(len=*), intent(in) :: toponame
    character(len=*), intent(in) :: dataname

    integer :: npts
    integer :: n_elev_classes
    integer :: elevclass
    character(len=64), allocatable :: attr_tags(:)

    npts = size(topo, 1)
    @assertEqual(npts, size(data, 1))
    n_elev_classes = size(topo, 2)
    @assertEqual(n_elev_classes, size(data, 2))

    allocate(attr_tags(2*n_elev_classes))
    do elevclass = 1, n_elev_classes
       attr_tags(elevclass) = dataname // two_digit_string(elevclass)
    end do
    do elevclass = 1, n_elev_classes
       attr_tags(n_elev_classes + elevclass) = toponame // two_digit_string(elevclass)
    end do
       
    call create_aVect_with_data_rows_are_points(this%av, &
         attr_tags = attr_tags, &
         data = reshape([data, topo], [npts, n_elev_classes * 2]))

  end subroutine create_av
    

  function create_calculator(this, topo, data, elevclass_bounds) &
       result(calculator)
    type(vertical_gradient_calculator_2nd_order_type) :: calculator
    class(TestVertGradCalc2ndOrder), intent(inout) :: this
    real(r8), intent(in) :: topo(:,:)  ! topo(i,j) is point i, elevation class j
    real(r8), intent(in) :: data(:,:)  ! data(i,j) is point i, elevation class j

    ! bounds of each elevation class; this array should have one more element than the
    ! number of elevation classes, since it contains lower and upper bounds for each
    ! elevation class
    real(r8), intent(in) :: elevclass_bounds(:)

    integer :: n_elev_classes
    character(len=16), allocatable :: elevclass_names(:)
    integer :: i

    n_elev_classes = size(data,2)
    @assertEqual(n_elev_classes + 1, size(elevclass_bounds))
    allocate(elevclass_names(1:n_elev_classes))
    do i = 1, n_elev_classes
       elevclass_names(i) = two_digit_string(i)
    end do

    call this%create_av(topo, data, 'topo', 'data')
    
    calculator = vertical_gradient_calculator_2nd_order_type( &
         attr_vect = this%av, &
         fieldname = 'data', &
         toponame = 'topo', &
         min_elevation_class = 1, &
         max_elevation_class = n_elev_classes, &
         elevclass_names = elevclass_names, &
         elevclass_bounds = elevclass_bounds)

  end function create_calculator

  subroutine calculateAndVerifyGradient_1point_ECmid(this, &
       elevclass_bounds, topo, data, expected_vertical_gradient, &
       msg)
    ! Parameterized test: Setup a vertical gradient calculator for a single point with 3
    ! ECs, calculate the vertical gradient for the middle EC, and verify that the
    ! vertical gradient matches the expected vertical gradient
    class(TestVertGradCalc2ndOrder), intent(inout) :: this
    real(r8), intent(in) :: elevclass_bounds(:)  ! elevation class bounds (should be size 4)
    real(r8), intent(in) :: topo(:)  ! topographic height for each EC (should be size 3)
    real(r8), intent(in) :: data(:)  ! data for each EC (should be size 3)
    real(r8), intent(in) :: expected_vertical_gradient
    character(len=*), intent(in) :: msg  ! message to print if test fails

    type(vertical_gradient_calculator_2nd_order_type) :: calculator
    real(r8) :: vertical_gradient(1)

    ! Check arguments
    @assertEqual(4, size(elevclass_bounds))
    @assertEqual(3, size(topo))
    @assertEqual(3, size(data))

    ! Setup
    calculator = this%create_calculator( &
         topo = reshape(topo, [1, 3]), &
         data = reshape(data, [1, 3]), &
         elevclass_bounds = elevclass_bounds)

    ! Exercise
    call calculator%calc_vertical_gradient(2, vertical_gradient)

    ! Verify
    @assertEqual(expected_vertical_gradient, vertical_gradient(1), tolerance=tol, message = msg)
  end subroutine calculateAndVerifyGradient_1point_ECmid

  @Test
  subroutine test_create_av(this)
    ! Tests the create_av helper routine
    class(TestVertGradCalc2ndOrder), intent(inout) :: this
    ! 3 points, 2 elevation classes
    real(r8), parameter :: topo(3,2) = reshape( &
         [1._r8, 2._r8, 3._r8, &
         4._r8, 5._r8, 6._r8], &
         [3, 2])
    real(r8), parameter :: data(3,2) = reshape( &
         [11._r8, 12._r8, 13._r8, &
         14._r8, 15._r8, 16._r8], &
         [3, 2])

    call this%create_av(topo, data, 'topo', 'data')

    @assertEqual([4._r8, 5._r8, 6._r8], aVect_exportRattr(this%av, 'topo' // two_digit_string(2)))

    @assertEqual([14._r8, 15._r8, 16._r8], aVect_exportRattr(this%av, 'data' // two_digit_string(2)))

  end subroutine test_create_av
    
  @Test
  subroutine test_calc_vertical_gradient_ECmid(this)
    ! Test calc_vertical_gradient with an elevation class in the middle of the range
    ! (standard case, not an edge case). This uses a single grid cell.
    class(TestVertGradCalc2ndOrder), intent(inout) :: this
    real(r8), parameter :: elevclass_bounds(4) = [0._r8, 100._r8, 200._r8, 300._r8]
    real(r8), parameter :: topo(3) = [50._r8, 125._r8, 275._r8]
    real(r8), parameter :: data(3) = [11._r8, 12._r8,  13._r8]
    real(r8) :: expected_vertical_gradient

    expected_vertical_gradient = (data(3) - data(1)) / (topo(3) - topo(1))
    call this%calculateAndVerifyGradient_1point_ECmid( &
         elevclass_bounds = elevclass_bounds, &
         topo = topo, &
         data = data, &
         expected_vertical_gradient = expected_vertical_gradient, &
         msg = 'test_calc_vertical_gradient_ECmid')
  end subroutine test_calc_vertical_gradient_ECmid

  @Test
  subroutine test_calc_vertical_gradient_ECbottom(this)
    ! Test calc_vertical_gradient with an elevation class at the bottom edge. This uses a
    ! single grid cell.
    class(TestVertGradCalc2ndOrder), intent(inout) :: this
    type(vertical_gradient_calculator_2nd_order_type) :: calculator
    real(r8), parameter :: elevclass_bounds(4) = [0._r8, 100._r8, 200._r8, 300._r8]
    real(r8), parameter :: topo(1,3) = reshape([50._r8, 125._r8, 275._r8], [1,3])
    real(r8), parameter :: data(1,3) = reshape([11._r8, 12._r8,  13._r8], [1,3])
    real(r8) :: vertical_gradient(1)
    real(r8) :: expected_vertical_gradient(1)

    calculator = this%create_calculator(topo=topo, data=data, &
         elevclass_bounds=elevclass_bounds)
    
    call calculator%calc_vertical_gradient(1, vertical_gradient)

    expected_vertical_gradient(1) = (data(1,2) - data(1,1)) / (topo(1,2) - topo(1,1))
    @assertEqual(expected_vertical_gradient, vertical_gradient, tolerance=tol)
    
  end subroutine test_calc_vertical_gradient_ECbottom
  
  @Test
  subroutine test_calc_vertical_gradient_ECtop(this)
    ! Test calc_vertical_gradient with an elevation class at the top edge. This uses a
    ! single grid cell.
    class(TestVertGradCalc2ndOrder), intent(inout) :: this
    type(vertical_gradient_calculator_2nd_order_type) :: calculator
    real(r8), parameter :: elevclass_bounds(4) = [0._r8, 100._r8, 200._r8, 300._r8]
    real(r8), parameter :: topo(1,3) = reshape([50._r8, 125._r8, 275._r8], [1,3])
    real(r8), parameter :: data(1,3) = reshape([11._r8, 12._r8,  13._r8], [1,3])
    real(r8) :: vertical_gradient(1)
    real(r8) :: expected_vertical_gradient(1)

    calculator = this%create_calculator(topo=topo, data=data, &
         elevclass_bounds=elevclass_bounds)
    
    call calculator%calc_vertical_gradient(3, vertical_gradient)

    expected_vertical_gradient(1) = (data(1,3) - data(1,2)) / (topo(1,3) - topo(1,2))
    @assertEqual(expected_vertical_gradient, vertical_gradient, tolerance=tol)
    
  end subroutine test_calc_vertical_gradient_ECtop

  @Test
  subroutine test_calc_vertical_gradient_1EC(this)
    ! Test calc_vertical_gradient with a single elevation class. This uses a single grid
    ! cell.
    class(TestVertGradCalc2ndOrder), intent(inout) :: this
    type(vertical_gradient_calculator_2nd_order_type) :: calculator
    real(r8), parameter :: elevclass_bounds(2) = [0._r8, 100._r8]
    real(r8), parameter :: topo(1,1) = reshape([50._r8], [1,1])
    real(r8), parameter :: data(1,1) = reshape([11._r8], [1,1])
    real(r8) :: vertical_gradient(1)
    real(r8) :: expected_vertical_gradient(1)

    calculator = this%create_calculator(topo=topo, data=data, &
         elevclass_bounds=elevclass_bounds)
    
    call calculator%calc_vertical_gradient(1, vertical_gradient)

    expected_vertical_gradient(1) = 0._r8
    @assertEqual(expected_vertical_gradient, vertical_gradient, tolerance=tol)

  end subroutine test_calc_vertical_gradient_1EC
    
  @Test
  subroutine test_calc_vertical_gradient_toposEqual(this)
    ! Test calc_vertical_gradient with topo values equal - make sure this edge case is
    ! handled correctly.
    class(TestVertGradCalc2ndOrder), intent(inout) :: this
    type(vertical_gradient_calculator_2nd_order_type) :: calculator
    real(r8), parameter :: elevclass_bounds(3) = [0._r8, 100._r8, 200._r8]
    real(r8), parameter :: topo(1,2) = reshape([100._r8, 100._r8], [1,2])
    real(r8), parameter :: data(1,2) = reshape([11._r8, 12._r8], [1,2])
    real(r8) :: vertical_gradient(1)
    real(r8) :: expected_vertical_gradient(1)

    calculator = this%create_calculator(topo=topo, data=data, &
         elevclass_bounds=elevclass_bounds)
    
    call calculator%calc_vertical_gradient(2, vertical_gradient)

    expected_vertical_gradient(1) = 0._r8
    @assertEqual(expected_vertical_gradient, vertical_gradient, tolerance=tol)
    
  end subroutine test_calc_vertical_gradient_toposEqual

  @Test
  subroutine test_calc_vertical_gradient_multiplePoints(this)
    ! Test calc_vertical_gradient with multiple grid cells. One has topo values equal,
    ! two are normal cases.
    class(TestVertGradCalc2ndOrder), intent(inout) :: this
    type(vertical_gradient_calculator_2nd_order_type) :: calculator

    integer, parameter :: npts = 3
    integer, parameter :: nelev = 2
    real(r8), parameter :: elevclass_bounds(3) = [0._r8, 100._r8, 200._r8]
    ! In the following, each line is one elevation class (with all points for that
    ! elevation class)
    real(r8), parameter :: topo(npts,nelev) = reshape( &
         [50._r8, 100._r8, 99._r8, &
         125._r8, 100._r8, 101._r8], &
         [npts,nelev])
    real(r8), parameter :: data(npts,nelev) = reshape( &
         [11._r8, 100._r8, 1000._r8, &
          12._r8, 200._r8, 2000._r8], &
          [npts,nelev])

    real(r8) :: vertical_gradient(npts)
    real(r8) :: expected_vertical_gradient(npts)

    calculator = this%create_calculator(topo=topo, data=data, &
         elevclass_bounds=elevclass_bounds)
    
    call calculator%calc_vertical_gradient(2, vertical_gradient)

    expected_vertical_gradient(1) = (data(1,2) - data(1,1)) / (topo(1,2) - topo(1,1))
    expected_vertical_gradient(2) = 0._r8
    expected_vertical_gradient(3) = (data(3,2) - data(3,1)) / (topo(3,2) - topo(3,1))
    @assertEqual(expected_vertical_gradient, vertical_gradient, tolerance=tol)
    
  end subroutine test_calc_vertical_gradient_multiplePoints
  
  
end module test_vertical_gradient_calculator_2nd_order
