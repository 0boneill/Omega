module cice_initialize

  use mpas_grid_types
  use mpas_timekeeping

  implicit none

  private
  public :: &
       cice_init

contains

  !--------------------------------------------------------------------------

  subroutine cice_init(block, clock, dt)

    use mpas_configure  

    use cice_mesh, only: init_boundary
    use cice_advection, only: init_advection
    use cice_dynamics, only: init_dynamics
    use cice_testing, only: init_spherical_test_case
    use cice_diagnostics, only: writeout_state
    use cice_forcing, only: init_forcing, get_forcing, forcing_file_comparison

    type(block_type), intent(inout) :: block
    type (MPAS_Clock_type), intent(in) :: clock

    real(kind=RKIND), intent(in) :: &
         dt
    
    type (MPAS_pool_type), pointer :: &
         mesh, &
         atmos_forcing, &
         tracers, &
         icestate, &
         hexdyn, &
         ocean_forcing, &
         boundary, &
         configs

    logical, pointer :: &
         config_use_velocity_solver, &
         config_use_advection, &
         config_use_forcing

    call MPAS_pool_get_subpool(block % structs, "mesh", mesh)
    call MPAS_pool_get_subpool(block % structs, "tracers", tracers)
    call MPAS_pool_get_subpool(block % structs, "atmos_forcing", atmos_forcing)
    call MPAS_pool_get_subpool(block % structs, "icestate", icestate)
    call MPAS_pool_get_subpool(block % structs, "hexdyn", hexdyn)
    call MPAS_pool_get_subpool(block % structs, "ocean_forcing", ocean_forcing)
    call MPAS_pool_get_subpool(block % structs, "boundary", boundary)

    configs => block % configs

    call MPAS_pool_get_config(configs, "config_use_velocity_solver", config_use_velocity_solver)
    call MPAS_pool_get_config(configs, "config_use_advection", config_use_advection)
    call MPAS_pool_get_config(configs, "config_use_forcing", config_use_forcing)

    call init_junk_values(mesh)

    ! calculate boundary variables
    call init_boundary(block)

    ! init dynamics
    if (config_use_velocity_solver) &
         call init_dynamics(block, dt)
    
    ! init advection
    if (config_use_advection) &
         call init_advection(block)
    
    ! init forcing
    if (config_use_forcing) then

       call init_forcing(&
            mesh, &
            atmos_forcing)
       
       call get_forcing(&
            mesh, &
            clock, &
            atmos_forcing)
       
    endif

    ! init ice state
    call init_ice_state(&
         configs, &
         mesh, &
         tracers, &
         hexdyn, &
         boundary, &
         atmos_forcing, &
         ocean_forcing)
    
    ! write out the initial condition
    !call writeout_state(block, 0)

  end subroutine cice_init

  !--------------------------------------------------------------------------

  subroutine init_junk_values(mesh)

    type(MPAS_pool_type), intent(inout) :: mesh

    integer :: &
         njunk

    real(kind=RKIND), parameter :: &
         value_junk = -1.0e34

    integer, pointer :: &
         nCells
    
    real(kind=RKIND), dimension(:), pointer :: &
         areaCell

    ! init variables
    call MPAS_pool_get_dimension(mesh, "nCells", nCells)

    call MPAS_pool_get_array(mesh, "areaCell", areaCell)

    njunk = nCells + 1
    
    areaCell(njunk) = value_junk

  end subroutine init_junk_values

  !--------------------------------------------------------------------------
  
  subroutine init_ice_state(&
       configs, &
       mesh, &
       tracers, &
       hexdyn, &
       boundary, &
       atmos_forcing, &
       ocean_forcing)

    use mpas_configure
    use cice_testing, only: &
         init_square_test_case_hex

    type (MPAS_pool_type), pointer, intent(inout) :: mesh
    type (MPAS_pool_type), pointer :: tracers
    type (MPAS_pool_type), pointer :: hexdyn
    type (MPAS_pool_type), pointer :: boundary
    type (MPAS_pool_type), pointer :: atmos_forcing
    type (MPAS_pool_type), pointer :: ocean_forcing
    type (MPAS_pool_type), pointer :: configs

    real(kind=RKIND), dimension(:), pointer :: &
         uVelocity, &
         vVelocity, &
         uOceanVelocity, &
         vOceanVelocity, &
         iceAreaCategoryPlot

    real(kind=RKIND), dimension(:,:,:), pointer :: &
         iceAreaCategory, &
         iceVolumeCategory, &
         snowVolumeCategory

    character(len=strKIND), pointer :: &
         config_initial_condition_type, &
         config_initial_velocity_type

    real(kind=RKIND), pointer :: &
         config_initial_ice_area, &
         config_initial_ice_volume, &
         config_initial_snow_volume, &
         config_initial_latitude_north, &
         config_initial_latitude_south, &
         config_initial_uvelocity, &
         config_initial_vvelocity

    integer, dimension(:), pointer :: &
         interiorVertex

    call MPAS_pool_get_array(tracers, "iceAreaCategory", iceAreaCategory, 1)
    call MPAS_pool_get_array(hexdyn, "iceAreaCategoryPlot", iceAreaCategoryPlot)
    call MPAS_pool_get_array(tracers, "iceVolumeCategory", iceVolumeCategory, 1)
    call MPAS_pool_get_array(tracers, "snowVolumeCategory", snowVolumeCategory, 1)

    call MPAS_pool_get_array(hexdyn, "uVelocity", uVelocity)
    call MPAS_pool_get_array(hexdyn, "vVelocity", vVelocity)

    call MPAS_pool_get_array(ocean_forcing, "uOceanVelocity", uOceanVelocity)
    call MPAS_pool_get_array(ocean_forcing, "vOceanVelocity", vOceanVelocity)

    call MPAS_pool_get_array(boundary, "interiorVertex", interiorVertex)

    call MPAS_pool_get_config(configs, "config_initial_condition_type", config_initial_condition_type)
    call MPAS_pool_get_config(configs, "config_initial_velocity_type", config_initial_velocity_type)
    call MPAS_pool_get_config(configs, "config_initial_ice_area", config_initial_ice_area)
    call MPAS_pool_get_config(configs, "config_initial_ice_volume", config_initial_ice_volume)
    call MPAS_pool_get_config(configs, "config_initial_snow_volume", config_initial_snow_volume)
    call MPAS_pool_get_config(configs, "config_initial_latitude_north", config_initial_latitude_north)
    call MPAS_pool_get_config(configs, "config_initial_latitude_south", config_initial_latitude_south)
    call MPAS_pool_get_config(configs, "config_initial_uvelocity", config_initial_uvelocity)
    call MPAS_pool_get_config(configs, "config_initial_vvelocity", config_initial_vvelocity)

    ! set volumes/areas
    if (trim(config_initial_condition_type) == "uniform") then

       call init_ice_state_uniform_ice(&
            mesh, &
            iceAreaCategory, &
            iceVolumeCategory, &
            snowVolumeCategory, &
            config_initial_ice_area, &
            config_initial_ice_volume, &
            config_initial_snow_volume, &
            config_initial_latitude_north, &
            config_initial_latitude_south)

    else if (trim(config_initial_condition_type) == "circle") then

       call init_ice_state_circle_of_ice(&
            mesh, &
            iceAreaCategory, &
            iceVolumeCategory, &
            snowVolumeCategory, &
            config_initial_ice_area, &
            config_initial_ice_volume, &
            config_initial_snow_volume)

    else if (trim(config_initial_condition_type) == "square") then

       call init_square_test_case_hex(&
            mesh, &
            tracers, &
            hexdyn, &
            boundary, &
            atmos_forcing, &
            ocean_forcing)

    else
       
       write(*,*) "Ice initial condition type unknown!"
       write(*,*) "config_initial_condition_type: ", trim(config_initial_condition_type)
       stop

    endif

    ! set velocities
    if (trim(config_initial_velocity_type) == "uniform") then

       call init_ice_velocity_uniform(&
            mesh, &
            uVelocity, &
            vVelocity, &
            config_initial_uvelocity, &
            config_initial_vvelocity, &
            interiorVertex)

    else if (trim(config_initial_velocity_type) == "ocean") then

       call init_ice_velocity_ocean(&
            mesh, &
            uVelocity, &
            vVelocity, &
            uOceanVelocity, &
            vOceanVelocity, &
            interiorVertex)

    else

       write(*,*) "Ice initial velocity type unknown!"
       write(*,*) "config_initial_velocity_type: ", trim(config_initial_velocity_type)
       stop

    endif

  end subroutine init_ice_state

  !--------------------------------------------------------------------------

  subroutine init_ice_state_uniform_ice(&
       mesh, &
       iceAreaCategory, &
       iceVolumeCategory, &
       snowVolumeCategory, &
       iceAreaInitial, &
       iceVolumeInitial, &
       snowVolumeInitial, &
       latitudeLimitNorth, &
       latitudeLimitSouth)

    type (MPAS_pool_type), pointer, intent(in) :: mesh
    
    real(kind=RKIND), dimension(:,:,:), intent(out) :: &
         iceAreaCategory, &
         iceVolumeCategory, &
         snowVolumeCategory

    real(kind=RKIND), intent(in) :: &
         iceAreaInitial, &
         iceVolumeInitial, &
         snowVolumeInitial, &
         latitudeLimitNorth, &
         latitudeLimitSouth

    integer :: &
         iCell

    real(kind=RKIND), parameter :: &
         pi = 3.14_RKIND, &
         rad_to_deg = pi / 180.0_RKIND

    integer, pointer :: &
         nCells

    real(kind=RKIND), dimension(:), pointer :: &
         latCell

    ! init variables
    call MPAS_pool_get_dimension(mesh, "nCells", nCells)

    call MPAS_pool_get_array(mesh, "latCell", latCell)

    do iCell = 1, nCells

       if (latCell(iCell) >= latitudeLimitNorth * rad_to_deg .or. &
           latCell(iCell) <= latitudeLimitSouth * rad_to_deg) then

          ! has ice
          iceAreaCategory(1,:,iCell)     = iceAreaInitial
          iceVolumeCategory(1,:,iCell)   = iceVolumeInitial
          snowVolumeCategory(1,:,iCell) = snowVolumeInitial
          
       else

          ! no ice
          iceAreaCategory(1,:,iCell)    = 0.0_RKIND
          iceVolumeCategory(1,:,iCell)  = 0.0_RKIND
          snowVolumeCategory(1,:,iCell) = 0.0_RKIND

       endif

    enddo ! iCell

  end subroutine init_ice_state_uniform_ice

  !--------------------------------------------------------------------------

  subroutine init_ice_state_circle_of_ice(&
       mesh, &
       iceAreaCategory, &
       iceVolumeCategory, &
       snowVolumeCategory, &
       iceAreaInitial, &
       iceVolumeInitial, &
       snowVolumeInitial)

    type (MPAS_pool_type), pointer, intent(in) :: mesh
    
    real(kind=RKIND), dimension(:,:,:), intent(out) :: &
         iceAreaCategory, &
         iceVolumeCategory, &
         snowVolumeCategory

    real(kind=RKIND), intent(in) :: &
         iceAreaInitial, &
         iceVolumeInitial, &
         snowVolumeInitial

    integer :: &
         iCell
    
    real(kind=RKIND), parameter :: &
         circle_radius = 1.0e6_RKIND

    integer, pointer :: &
         nCells
    
    real(kind=RKIND), dimension(:), pointer :: &
         xCell, &
         yCell, &
         zCell
   
    ! init variables
    call MPAS_pool_get_dimension(mesh, "nCells", nCells)

    call MPAS_pool_get_array(mesh, "xCell", xCell)
    call MPAS_pool_get_array(mesh, "yCell", yCell)
    call MPAS_pool_get_array(mesh, "zCell", zCell)

    do iCell = 1, nCells
       
       if (sqrt(xCell(iCell)**2 + zCell(iCell)**2) < circle_radius .and. yCell(iCell) > 0.0_RKIND) then
          
          ! has ice
          iceAreaCategory(1,:,iCell)    = iceAreaInitial
          iceVolumeCategory(1,:,iCell)  = iceVolumeInitial
          snowVolumeCategory(1,:,iCell) = snowVolumeInitial
          
       else
          
          ! no ice
          iceAreaCategory(1,:,iCell)    = 0.0_RKIND
          iceVolumeCategory(1,:,iCell)  = 0.0_RKIND
          snowVolumeCategory(1,:,iCell) = 0.0_RKIND
          
       endif
       
    enddo ! iCell
    
  end subroutine init_ice_state_circle_of_ice

  !--------------------------------------------------------------------------

  subroutine init_ice_velocity_uniform(&
       mesh, &
       uVelocity, &
       vVelocity, &
       InitialUVelocity, &
       InitialVVelocity, &
       interiorVertex)
    
    type (MPAS_pool_type), pointer, intent(in) :: mesh
    
    real(kind=RKIND), dimension(:), intent(out) :: &
         uVelocity, &
         vVelocity
    
    real(kind=RKIND), intent(in) :: &
         InitialUVelocity, &
         InitialVVelocity

    integer, dimension(:), intent(in) :: &
         interiorVertex
    
    integer :: &
         iVertex

    integer, pointer :: &
         nVertices

    call MPAS_pool_get_dimension(mesh, "nVertices", nVertices)

    do iVertex = 1, nVertices

       if (interiorVertex(iVertex) == 1) then
          
          uVelocity(iVertex) = InitialUVelocity
          vVelocity(iVertex) = InitialVVelocity
          
       else

          uVelocity(iVertex) = 0.0_RKIND
          vVelocity(iVertex) = 0.0_RKIND

       endif

    enddo ! iVertex

  end subroutine init_ice_velocity_uniform

  !--------------------------------------------------------------------------

  subroutine init_ice_velocity_ocean(&
       mesh, &
       uVelocity, &
       vVelocity, &
       uOceanVelocity, &
       vOceanVelocity, &
       interiorVertex)

    use cice_mesh, only: &
         interpolate_cell_to_vertex
    
    type (MPAS_pool_type), pointer, intent(in) :: mesh
    
    real(kind=RKIND), dimension(:), intent(out) :: &
         uVelocity, &
         vVelocity
    
    real(kind=RKIND), dimension(:), intent(in) :: &    
         uOceanVelocity, &
         vOceanVelocity

    integer, dimension(:), intent(in) :: &
         interiorVertex

    integer :: &
         iVertex

    integer, pointer :: &
         nVertices

    real(kind=RKIND), dimension(:), allocatable :: &
         uOceanVelocityVertex, &
         vOceanVelocityVertex

    call MPAS_pool_get_dimension(mesh, "nVertices", nVertices)

    allocate(uOceanVelocityVertex(nVertices))
    allocate(vOceanVelocityVertex(nVertices))

    call interpolate_cell_to_vertex(mesh, &
         uOceanVelocityVertex, &
         uOceanVelocity)

    call interpolate_cell_to_vertex(mesh, &
         vOceanVelocityVertex, &
         vOceanVelocity)

    do iVertex = 1, nVertices
    
       if (interiorVertex(iVertex) == 1) then

          uVelocity(iVertex) = uOceanVelocityVertex(iVertex)
          vVelocity(iVertex) = vOceanVelocityVertex(iVertex)

       else

          uVelocity(iVertex) = 0.0_RKIND
          vVelocity(iVertex) = 0.0_RKIND

       endif

    enddo ! iVertex

    deallocate(uOceanVelocityVertex)
    deallocate(vOceanVelocityVertex)

  end subroutine init_ice_velocity_ocean

  !--------------------------------------------------------------------------

end module cice_initialize
