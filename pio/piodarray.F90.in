#define __PIO_FILE__ 'piodarray'
!>
!! @file 
!! $Revision$
!! $LastChangedDate$
!! @brief Read and write Routines for decomposed data.
!<
module piodarray
  use pio_types, only : file_desc_t, io_desc_t, var_desc_t, pio_noerr, iosystem_desc_t, &
	pio_iotype_pbinary, pio_iotype_binary, pio_iotype_direct_pbinary, &
	pio_iotype_netcdf, pio_iotype_pnetcdf, pio_iotype_netcdf4p, pio_iotype_netcdf4c, &
        PIO_MAX_VAR_DIMS, pio_iotype_vdc2
  use pio_kinds
  use pio_support
  use alloc_mod
#ifndef NO_C_SIZEOF
  use iso_c_binding, only : c_sizeof  ! _EXTERNAL
#else
#define c_sizeof(x)  size(transfer (x, xxx_sizeof_data))
#endif


#ifdef TIMING
  use perf_mod, only : t_startf, t_stopf   !_EXTERNAL
#endif
#ifndef NO_MPIMOD
  use mpi           !_EXTERNAL
#endif
#ifdef USE_PNETCDF_MOD
  use pnetcdf
#endif
  implicit none
#ifdef NO_MPIMOD
  include 'mpif.h'            !_EXTERNAL
#endif

  private
  public :: pio_read_darray, pio_write_darray, pio_set_buffer_size_limit

#if defined(NO_C_SIZEOF)
  character, private :: xxx_sizeof_data(32)
#endif

  
!> 
!! @defgroup PIO_write_darray PIO_write_darray
!! @brief The overloaded PIO_write_darray writes a distributed array to disk.
!<
  interface PIO_write_darray
! TYPE real,int,double
! DIMS 1,2,3,4,5,6,7
     module procedure write_darray_{DIMS}d_{TYPE}
  end interface


!> 
!! @defgroup PIO_read_darray PIO_read_darray
!! @brief The overloaded PIO_read_darray function reads a distributed array from disk.
!<
  interface PIO_read_darray
! TYPE real,int,double
! DIMS 1,2,3,4,5,6,7
     module procedure read_darray_{DIMS}d_{TYPE}
  end interface


  character(len=*), parameter, private  :: modName='piodarray'
  integer :: total_buffsize=0
  integer :: pio_buffer_size_limit= 100000000   ! 100MB default

#ifdef MEMCHK
integer :: msize, rss, mshare, mtext, mstack, lastrss=0
#endif

contains

  subroutine pio_set_buffer_size_limit(limit)
    integer, intent(in) :: limit 

    if(limit<0) then
       call piodie(__PIO_FILE__,__LINE__,' bad value to buffer_size_limit',limit)
    end if
    pio_buffer_size_limit=limit

  end subroutine pio_set_buffer_size_limit

! TYPE real,int,double
  subroutine write_darray_1d_cinterface_{TYPE} (File,varDesc,ioDesc, arraylen, array, iostat, fillval)
    use iso_c_binding
    ! !DESCRIPTION:
    !  Writes a 2-d slab of TYPE to a netcdf file.
    !
    ! !REVISION HISTORY:
    !  same as module

    ! !INPUT PARAMETERS:

    type (File_desc_t), intent(inout) :: &
         File                   ! file information

    type (var_desc_t), intent(inout) :: &
         varDesc                      ! variable descriptor

    type (io_desc_t), intent(inout) :: &
         ioDesc                      ! variable descriptor

    {VTYPE}, dimension(*), target, intent(in) ::  &
         array                 ! array to be written

    {VTYPE}, optional, target, intent(in) :: fillval    ! rearrange receiver fill value
    type(iosystem_desc_t), pointer :: ios
    integer,intent(in) :: arraylen
    integer(i4), intent(out) :: iostat

    character(len=*), parameter :: subName=modName//'::write_darray_{TYPE}'

    interface
       integer(C_INT) function PIOc_write_darray(ncid, vid, ioid, arraylen, array, fillvalue) &
            bind(C,name="PIOc_write_darray")
         use iso_c_binding
         integer(C_INT), value :: ncid
         integer(C_INT), value :: vid
         integer(C_INT), value :: ioid
         integer(C_SIZE_T), value :: arraylen
         type(C_PTR), value :: array
         type(C_PTR), value :: fillvalue
       end function PIOc_write_darray
    end interface

    if(present(fillval)) then
       iostat = PIOc_write_darray(file%fh, varDesc%varid, iodesc%ioid, int(arraylen,C_SIZE_T),C_LOC(array), C_LOC(fillval))
    else
       iostat = PIOc_write_darray(file%fh, varDesc%varid, iodesc%ioid, int(arraylen,C_SIZE_T), C_LOC(array), C_NULL_PTR)
    endif

  end subroutine write_darray_1d_cinterface_{TYPE}

! TYPE real,int,double
!> 
!! @public
!! @ingroup PIO_write_darray
!! @brief Writes a 1D array of type {TYPE}. 
!! @details
!! @param File    \ref file_desc_t
!! @param varDesc \ref var_desc_t
!! @param ioDesc  \ref io_desc_t
!! @param array  : The data to be written
!! @param iostat : The status returned from this routine (see \ref PIO_seterrorhandling for details)
!! @param fillval : An optional fill value to fill holes in the data written
!<  
  subroutine write_darray_1d_{TYPE} (File,varDesc,ioDesc, array, iostat, fillval)
    ! !DESCRIPTION:
    !  Writes a block of TYPE to a netcdf file.
    !
    ! !REVISION HISTORY:
    !  same as module

    ! !INPUT PARAMETERS:

    type (File_desc_t), intent(inout) :: &
         File                   ! file information

    type (var_desc_t), intent(inout) :: &
         varDesc                      ! variable descriptor

    type (io_desc_t), intent(inout) :: &
         ioDesc                      ! variable descriptor

    {VTYPE}, dimension(:), target, intent(in) ::  &
         array                 ! array to be written

    {VTYPE}, optional, target, intent(in) :: fillval    ! rearrange receiver fill value
    integer(i4), intent(out) :: iostat
    integer :: ierr

    character(len=*), parameter :: subName=modName//'::write_darray_{TYPE}'

    call write_darray_1d_cinterface_{TYPE} (file, varDesc, iodesc, size(array), array, iostat, fillval)

  end subroutine write_darray_1d_{TYPE}

! TYPE real,int,double
! DIMS 2,3,4,5,6,7
!> 
!! @public
!! @ingroup PIO_write_darray
!! @brief Writes a {DIMS}D array of type {TYPE}. 
!! @details
!! @param File @ref file_desc_t
!! @param varDesc @ref var_desc_t
!! @param ioDesc  @ref io_desc_t
!! @param array  : The data to be written
!! @param iostat : The status returned from this routine (see \ref PIO_seterrorhandling for details)
!! @param fillval : An optional fill value to fill holes in the data written
!<  
  subroutine write_darray_{DIMS}d_{TYPE} (File,varDesc,ioDesc, array, iostat, fillval)
    ! !INPUT PARAMETERS:

    type (File_desc_t), intent(inout) :: &
         File                   ! file information

    type (var_desc_t), intent(inout) :: &
         varDesc                      ! variable descriptor

    type (io_desc_t), intent(inout) :: &
         ioDesc                      ! variable descriptor

    {VTYPE}, intent(in) ::  &
         array{DIMSTR}                 ! array to be written

    {VTYPE}, optional, intent(in) :: fillval    ! rearrange receiver fill value

    integer(i4), intent(out) :: iostat
    {VTYPE} :: transvar(1), dumbvar(0)

! This code is required due to a bug in gfortran 4.7.2
#if (__GFORTRAN__) &&  (__GNUC__ == 4) && (__GNUC_MINOR__ < 8)
    {VTYPE}, allocatable :: acopy(:)
    integer :: isize 

    isize= size(array)
    allocate(acopy(isize))
    acopy = reshape(array,(/isize/))
    call write_darray_1d_{TYPE} (File, varDesc, iodesc, acopy, iostat, fillval)
    deallocate(acopy)
    return
#else
! cannot call transfer function with a 0 sized array
    if(size(array)==0) then
       call write_darray_1d_{TYPE} (File, varDesc, iodesc, dumbvar, iostat)
    else 
       call write_darray_1d_{TYPE} (File, varDesc, iodesc, transfer(array,transvar), iostat, fillval)
    end if
#endif
  end subroutine write_darray_{DIMS}d_{TYPE}

! TYPE real,int,double
  subroutine read_darray_1d_cinterface_{TYPE} (File,varDesc,ioDesc, arraylen, array, iostat)
    use iso_c_binding
    ! !DESCRIPTION:
    !  Writes a 2-d slab of TYPE to a netcdf file.
    !
    ! !REVISION HISTORY:
    !  same as module

    ! !INPUT PARAMETERS:

    type (File_desc_t), intent(inout) :: &
         File                   ! file information

    type (var_desc_t), intent(inout) :: &
         varDesc                      ! variable descriptor

    type (io_desc_t), intent(inout) :: &
         ioDesc                      ! variable descriptor

    {VTYPE}, dimension(*), target, intent(out) ::  &
         array                 ! array to be read

    integer,intent(in) :: arraylen
    integer(i4), intent(out) :: iostat

    character(len=*), parameter :: subName=modName//'::write_darray_{TYPE}'

    interface
       integer(C_INT) function PIOc_read_darray(ncid, vid, ioid, arraylen, array) &
            bind(C,name="PIOc_read_darray")
         use iso_c_binding
         integer(C_INT), value :: ncid
         integer(C_INT), value :: vid
         integer(C_INT), value :: ioid
         integer(C_SIZE_T), value :: arraylen
         type(C_PTR), value :: array
       end function PIOc_read_darray
    end interface
    iostat = PIOc_read_darray(file%fh, varDesc%varid, iodesc%ioid, int(arraylen,C_SIZE_T), C_LOC(array))


  end subroutine read_darray_1d_cinterface_{TYPE}
! TYPE real,int,double
!> 
!! @public
!! @ingroup PIO_read_darray
!! @brief
!! @details
!! @param File @ref file_desc_t
!! @param varDesc @ref var_desc_t
!! @param ioDesc @ref io_desc_t
!! @param array  : The read data
!! @param iostat : The status returned from this routine (see \ref PIO_seterrorhandling for details)
!<
  subroutine read_darray_1d_{TYPE} (File,varDesc, ioDesc, array, iostat)
    ! !DESCRIPTION:
    !  Reads a slab of TYPE from a netcdf file.
    !
    ! !REVISION HISTORY:
    !  same as module

    ! !INPUT PARAMETERS:

    type (File_desc_t), intent(inout) :: &
	 File                   ! file information

    type (var_desc_t), intent(inout) :: &
	 varDesc                      ! variable descriptor

    type (io_desc_t), intent(inout) :: &
	 ioDesc                      ! iodecomp descriptor

    {VTYPE}, dimension(:), intent(out) ::  &
	 array                 ! array to be read

    integer(i4), intent(out) :: iostat

    character(len=*), parameter :: subName=modName//'::read_darray_{TYPE}'
	

    call read_darray_1d_cinterface_{TYPE} (file, vardesc, iodesc, size(array), array, iostat)


  end subroutine read_darray_1d_{TYPE}
 
! TYPE real,int,double
! DIMS 2,3,4,5,6,7
!> 
!! @public
!! @ingroup PIO_read_darray
!! @brief Reads a {DIMS}D array of type {TYPE}. 
!! @details
!! @param File @ref file_desc_t
!! @param varDesc @ref var_desc_t
!! @param ioDesc @ref io_desc_t
!! @param array  : The read data  
!! @param iostat : The status returned from this routine (see \ref PIO_seterrorhandling for details)
!<
  subroutine read_darray_{DIMS}d_{TYPE} (File,varDesc,ioDesc, array, iostat)
    ! !INPUT PARAMETERS:

    type (File_desc_t), intent(inout) :: &
	 File                   ! file information

    type (var_desc_t), intent(inout) :: &
	 varDesc                      ! variable descriptor

    type (io_desc_t), intent(inout) :: &
	 ioDesc                      ! iodecomp descriptor

    {VTYPE}, intent(out) ::  array{DIMSTR}                 ! array to be read

    integer(i4), intent(out) :: iostat

    {VTYPE}, pointer :: tmpvar(:)

    call alloc_check(tmpvar,size(array))
    call read_darray_1d_{TYPE} (File, varDesc, iodesc, tmpvar, iostat)
    array = reshape(tmpvar,shape(array))
    call dealloc_check(tmpvar)

  end subroutine read_darray_{DIMS}d_{TYPE}


end module piodarray

