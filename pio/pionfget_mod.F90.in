#define __PIO_FILE__ "pionfget_mod.F90"
!>
!! @file 
!! $Revision$
!! $LastChangedDate$
!! @brief Read Routines for non-decomposed NetCDF data.
!<
module pionfget_mod
  use iso_c_binding
#ifdef TIMING
  use perf_mod, only : t_startf, t_stopf      ! _EXTERNAL
#endif
  use pio_kinds, only: i4,r4,r8,pio_offset
  use pio_types, only : file_desc_t, iosystem_desc_t, var_desc_t, &
	pio_iotype_pbinary, pio_iotype_binary, pio_iotype_direct_pbinary, &
	pio_iotype_netcdf, pio_iotype_pnetcdf, pio_iotype_netcdf4p, pio_iotype_netcdf4c, &
	pio_noerr
  implicit none
  private
!>
!! @defgroup PIO_get_var PIO_get_var
!! @brief Reads non-decomposed data from a NetCDF file
!! @details The get_var interface is provided as a simplified interface to
!!  read variables from a NetCDF format file.   The variable is read on the 
!!  root IO task and broadcast in its entirety to all tasks.  
!<
  public :: get_var
  interface get_var
     module procedure get_var_{DIMS}d_{TYPE}, get_var_vdesc_{DIMS}d_{TYPE}
     !  DIMS 1,2,3,4,5
     module procedure get_vara_{DIMS}d_{TYPE}, get_vara_vdesc_{DIMS}d_{TYPE}
     module procedure get_var1_{TYPE}, get_var1_vdesc_{TYPE}
  end interface

 character(len=*), parameter :: modName='pionfget_mod'

CONTAINS

!>
!! @public
!! @ingroup PIO_get_var
!! @brief Reads non-decomposed fields from a NetCDF file
!! @details
!! @param File @ref file_desc_t
!! @param varid : The netcdf variable identifier
!! @param index :  a multidimensional index that specifies which value to get
!! @param ival : The value for the netcdf metadata
!! @retval ierr @ref error_return
!<
  integer function get_var1_{TYPE} (File,varid, index, ival) result(ierr)
    type (File_desc_t), intent(in) :: File
    integer, intent(in) :: varid, index(:)
    {VTYPE}, intent(out) :: ival


    ierr = get_var1_id_{TYPE} (file%fh, varid, index, ival)

  end function get_var1_{TYPE}

  integer function get_var1_id_{TYPE} (ncid,varid, index, ival) result(ierr)
    integer, intent(in) :: ncid
    integer, intent(in) :: varid, index(:)
    {VTYPE}, intent(out) :: ival
    interface
       integer(C_INT) function PIOc_get_var1_{NCTYPE} (ncid, varid, ival) &
            bind(C,name="PIOc_get_var1_{NCTYPE}")
         use iso_c_binding
         integer(C_INT), value :: ncid
         integer(C_INT), value :: varid
         {CTYPE} :: ival
       end function PIOc_get_var1_{NCTYPE}
    end interface

#ifdef TIMING
    call t_startf("pio_get_var1_{TYPE}")
#endif
    ierr = PIOc_get_var1_{NCTYPE} (ncid, varid, ival)
#ifdef TIMING
    call t_stopf("pio_get_var1_{TYPE}")
#endif
  end function get_var1_id_{TYPE}

!>
!! @public
!! @ingroup PIO_get_var
!! @brief Writes an netcdf attribute to a file
!! @details
!! @param File @ref file_desc_t
!! @param vardesc @ref var_desc_t
!! @param index :  a multidimensional index that specifies which value to get
!! @param ival : The value for the netcdf metadata
!! @retval ierr @ref error_return
!<
  integer function get_var1_vdesc_{TYPE} (File,vardesc, index, ival) result(ierr)
    type (File_desc_t), intent(in) :: File
    type(var_desc_t), intent(in) :: vardesc
    integer, intent(in) :: index(:)
    {VTYPE}, intent(out) :: ival

    character(len=*), parameter :: subName=modName//'::get_var1_vdesc_{TYPE}'

    ierr = get_var1_{TYPE} (File, vardesc%varid, index, ival)

  end function get_var1_vdesc_{TYPE}


! DIMS 1,2,3,4,5
!>
!! @public
!! @ingroup PIO_get_var
!! @brief Writes an netcdf attribute to a file
!! @details
!! @param File @ref file_desc_t
!! @param varid : The netcdf variable identifier
!! @param start : A vector of size_t integers specifying the index in
!!   the variable where the first of the data values will be read. The
!!   indices are relative to 0, so for example, the first data value of
!!   a variable would have index (0, 0, ... , 0). The length of start
!!   must be the same as the number of dimensions of the specified
!!   variable. The elements of start correspond, in order, to the
!!   variable's dimensions. Hence, if the variable is a record variable,
!!   the first index would correspond to the starting record number for
!!   reading the data values.
!! @param count : A vector of size_t integers specifying the edge
!!   lengths along each dimension of the block of data values to be
!!   read. To read a single value, for example, specify count as (1, 1,
!!   ... , 1). The length of count is the number of dimensions of the
!!   specified variable. The elements of count correspond, in order, to
!!   the variable's dimensions. Hence, if the variable is a record
!!   variable, the first element of count corresponds to a count of the
!!   number of records to read.
!! Note: setting any element of the count array to zero causes the function to exit without error, and without doing anything. 
!! @param ival : The value for the netcdf metadata
!! @retval ierr @ref error_return
!<
  integer function get_vara_{DIMS}d_{TYPE} (File,varid, start, count, ival) result(ierr)
    type (File_desc_t), intent(in) :: File
    integer, intent(in) :: varid, start(:), count(:)
    {VTYPE}, intent(out) :: ival{DIMSTR}
         
    character(len=*), parameter :: subName=modName//'::get_vara_{DIMS}d_{TYPE}'
    ierr = PIO_NOERR

  end function get_vara_{DIMS}d_{TYPE}

! DIMS 1,2,3,4,5
!>
!! @public
!! @ingroup PIO_get_var
!! @brief Writes an netcdf attribute to a file
!! @details
!! @param File @ref file_desc_t
!! @param vardesc @ref var_desc_t
!! @param start : A vector of size_t integers specifying the index in
!!   the variable where the first of the data values will be read. The
!!   indices are relative to 0, so for example, the first data value of
!!   a variable would have index (0, 0, ... , 0). The length of start
!!   must be the same as the number of dimensions of the specified
!!   variable. The elements of start correspond, in order, to the
!!   variable's dimensions. Hence, if the variable is a record variable,
!!   the first index would correspond to the starting record number for
!!   reading the data values.
!! @param count : A vector of size_t integers specifying the edge
!!   lengths along each dimension of the block of data values to be
!!   read. To read a single value, for example, specify count as (1, 1,
!!   ... , 1). The length of count is the number of dimensions of the
!!   specified variable. The elements of count correspond, in order, to
!!   the variable's dimensions. Hence, if the variable is a record
!!   variable, the first element of count corresponds to a count of the
!!   number of records to read.
!! Note: setting any element of the count array to zero causes the function to exit without error, and without doing anything. 
!! @param ival : The value for the netcdf metadata
!! @retval ierr @ref error_return
!<
  integer function get_vara_vdesc_{DIMS}d_{TYPE} (File,vardesc, start, count, ival) result(ierr)
    type (File_desc_t), intent(in) :: File
    type(var_desc_t), intent(in) :: vardesc
    integer, intent(in) :: start(:), count(:)
    {VTYPE}, intent(out) :: ival{DIMSTR}

    character(len=*), parameter :: subName=modName//'::get_vara_vdesc_{DIMS}d_{TYPE}'

    ierr = get_vara_{DIMS}d_{TYPE} (File, vardesc%varid, start, count, ival)

  end function get_vara_vdesc_{DIMS}d_{TYPE}


  subroutine replace_c_null(istr)
    use iso_c_binding, only : C_NULL_CHAR
    character(len=*),intent(inout) :: istr
    integer :: i
    do i=1,len(istr)
       if(istr(i:i) == C_NULL_CHAR) istr(i:i)=''
    end do
  end subroutine replace_c_null



!>
!! @public
!! @ingroup PIO_get_var
!! @brief Writes an netcdf attribute to a file
!! @details
!! @param File @ref file_desc_t
!! @param varid : The netcdf variable identifier
!! @param ival : The value for the netcdf metadata
!! @retval ierr @ref error_return
!<
  integer function get_var_0d_text (File,varid, ival) result(ierr)
    type (File_desc_t), intent(in) :: File
    integer, intent(in) :: varid
    character(len=*), intent(out) :: ival
    integer :: i
    interface
       integer(C_INT) function PIOc_get_var_text (ncid, varid, ival) &
            bind(C,name="PIOc_get_var_text")
         use iso_c_binding
         integer(C_INT), value :: ncid
         integer(C_INT), value :: varid
         character(C_CHAR) :: ival
       end function PIOc_get_var_text
    end interface
    ierr = PIOc_get_var_text(File%fh, varid, ival)
    call replace_c_null(ival)

  end function Get_var_0d_text


! TYPE int,real,double
! DIMS 0
  integer function get_var_0d_{TYPE} (File,varid, ival) result(ierr)
    use iso_c_binding
    type (File_desc_t), intent(in) :: File
    integer, intent(in) :: varid
    {VTYPE}, intent(out) :: ival
    integer :: i
    interface
       integer(C_INT) function PIOc_get_var_{NCTYPE} (ncid, varid, ival) &
            bind(C,name="PIOc_get_var_{NCTYPE}")
         use iso_c_binding
         integer(C_INT), value :: ncid
         integer(C_INT), value :: varid
         {CTYPE} :: ival
       end function PIOc_get_var_{NCTYPE}
    end interface
    ierr = PIOc_get_var_{NCTYPE} (File%fh, varid, ival)
       
  end function Get_var_0d_{TYPE}

! TYPE text
! DIMS 1,2,3,4,5
  integer function get_var_{DIMS}d_text (File,varid, ival) result(ierr)
    type (File_desc_t), intent(in) :: File
    integer, intent(in) :: varid
    character(len=*), intent(out) :: ival{DIMSTR}
    integer :: dimlen({DIMS})
    integer :: i
    integer :: j, k, m,n, q
    interface
       integer(C_INT) function PIOc_get_var_text (ncid, varid, ival) &
            bind(C,name="PIOc_get_var_text")
         use iso_c_binding
         integer(C_INT), value :: ncid
         integer(C_INT), value :: varid
         character(C_CHAR) :: ival
       end function PIOc_get_var_text
    end interface
    dimlen = size(ival)

#if({DIMS}==5)
    ierr = PIOc_get_var_text(File%fh, varid, ival(1,1,1,1,1))
    do q=1,dimlen(5)
    do n=1,dimlen(4)
    do m=1,dimlen(3)
    do k=1,dimlen(2)
    do j=1,dimlen(1)
       call replace_c_null(ival(j,k,m,n,q))
    end do
    end do
    end do
    end do
    end do
#endif
#if({DIMS}==4)
    ierr = PIOc_get_var_text(File%fh, varid, ival(1,1,1,1))
    do n=1,dimlen(4)
    do m=1,dimlen(3)
    do k=1,dimlen(2)
    do j=1,dimlen(1)
       call replace_c_null(ival(j,k,m,n))
    end do
    end do
    end do
    end do
#endif
#if({DIMS}==3)
    ierr = PIOc_get_var_text(File%fh, varid, ival(1,1,1))
    do m=1,dimlen(3)
    do k=1,dimlen(2)
    do j=1,dimlen(1)
       call replace_c_null(ival(j,k,m))
    end do
    end do
    end do
#endif
#if({DIMS}==2)
    ierr = PIOc_get_var_text(File%fh, varid, ival(1,1))
    do k=1,dimlen(2)
    do j=1,dimlen(1)
       call replace_c_null(ival(j,k))
    end do
    end do
#endif
#if({DIMS}==1)
    ierr = PIOc_get_var_text(File%fh, varid, ival(1))
    do j=1,dimlen(1)
       call replace_c_null(ival(j))
    end do
#endif


  end function get_var_{DIMS}d_text

! TYPE int,real,double
! DIMS 1,2,3,4,5
  integer function get_var_{DIMS}d_{TYPE}_internal  (ncid,varid, ival) result(ierr)
    integer, intent(in) :: ncid
    integer, intent(in) :: varid
    {VTYPE}, intent(out) :: ival(*)
    type(iosystem_desc_t), pointer :: ios
    character(len=*), parameter :: subName=modName//'::get_var_{DIMS}d_{TYPE}'
    integer :: iotype, mpierr, msg, ilen, itype
#if ({DIMS} > 0)
    integer :: dims({DIMS})
    integer :: i
#endif
    integer(kind=PIO_OFFSET) :: isize
    interface
       integer(C_INT) function PIOc_get_var_{NCTYPE} (ncid, varid, ival) &
            bind(C,name="PIOc_get_var_{NCTYPE}")
         use iso_c_binding
         integer(C_INT), value :: ncid
         integer(C_INT), value :: varid
         {CTYPE}  :: ival
       end function PIOc_get_var_{NCTYPE}
    end interface
    ierr = PIOc_get_var_{NCTYPE} (ncid, varid, ival(1))

  end function get_var_{DIMS}d_{TYPE}_internal
! TYPE int,real,double
! DIMS 1,2,3,4,5
  integer function get_var_{DIMS}d_{TYPE} (File,varid, ival) result(ierr)
    type (File_desc_t), intent(in) :: File
    integer, intent(in) :: varid
    {VTYPE}, intent(out) :: ival{DIMSTR}
    type(iosystem_desc_t), pointer :: ios
    character(len=*), parameter :: subName=modName//'::get_var_{DIMS}d_{TYPE}'
    integer :: iotype, mpierr, msg, ilen, itype
#if ({DIMS} > 0)
    integer :: dims({DIMS})
    integer :: i
#endif
    integer(kind=PIO_OFFSET) :: isize

    ierr = get_var_{DIMS}d_{TYPE}_internal(File%fh, varid, ival)


  end function get_var_{DIMS}d_{TYPE}


!>
!! @public
!! @ingroup PIO_get_var
!! @brief Writes an netcdf attribute to a file
!! @details
!! @param File @ref file_desc_t
!! @param vardesc @ref var_desc_t
!! @param ival : The value for the netcdf metadata
!! @retval ierr @ref error_return
!<
  integer function get_var_vdesc_{DIMS}d_{TYPE} (File,vardesc, ival) result(ierr)
    type (File_desc_t), intent(in) :: File
    type(var_desc_t), intent(in) :: vardesc
    {VTYPE}, intent(out) :: ival{DIMSTR}

    character(len=*), parameter :: subName=modName//'::get_var_vdesc_{DIMS}d_{TYPE}'

    ierr = get_var_{DIMS}d_{TYPE} (File, vardesc%varid, ival)

  end function get_var_vdesc_{DIMS}d_{TYPE}
end module pionfget_mod
