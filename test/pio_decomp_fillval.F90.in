! nc write 1d array with fillvalues (the holes are explicitly specified)
PIO_TF_TEMPLATE<PIO_TF_PREDEF_TYPENAME PIO_TF_DATA_TYPE, PIO_TF_PREDEF_TYPENAME PIO_TF_FC_DATA_TYPE>
PIO_TF_AUTO_TEST_SUB_BEGIN nc_write_1d_explicit_fval
  implicit none
  integer, parameter :: VEC_LOCAL_SZ = 7
  type(var_desc_t)  :: pio_var
  type(file_desc_t) :: pio_file
  character(len=PIO_TF_MAX_STR_LEN) :: filename
  type(io_desc_t) :: iodesc
  integer, dimension(VEC_LOCAL_SZ) :: compdof, compdof_rel_disps
  ! Compdof value to suggest that data point is a hole, this hole
  ! is usually filled with a fillvalue
  integer, parameter :: PIO_COMPDOF_FILLVAL = 0
  PIO_TF_FC_DATA_TYPE, dimension(VEC_LOCAL_SZ) :: wbuf, rbuf, exp_val
  ! The buffer fillvalue to be used when writing data
  PIO_TF_FC_DATA_TYPE, PARAMETER :: BUF_FILLVAL = -2
  integer, dimension(1) :: dims
  integer :: pio_dim
  integer :: i, ierr, lsz
  ! iotypes = valid io types
  integer, dimension(:), allocatable :: iotypes
  character(len=PIO_TF_MAX_STR_LEN), dimension(:), allocatable :: iotype_descs
  integer :: num_iotypes

  do i=1,VEC_LOCAL_SZ
    compdof_rel_disps(i) = i
  end do
  dims(1) = VEC_LOCAL_SZ * pio_tf_world_sz_
  compdof = VEC_LOCAL_SZ * pio_tf_world_rank_ + compdof_rel_disps

  wbuf = compdof
  exp_val = compdof
  rbuf = 0

  ! Even indices need to be filled with (BUF_FILLVAL == -2)
  do i=1,VEC_LOCAL_SZ,2
    compdof(i) = PIO_COMPDOF_FILLVAL
    exp_val(i) = BUF_FILLVAL
  end do

  call PIO_initdecomp(pio_tf_iosystem_, PIO_TF_DATA_TYPE, dims, compdof, iodesc)

  num_iotypes = 0
  call PIO_TF_Get_nc_iotypes(iotypes, iotype_descs, num_iotypes)
  filename = "test_pio_decomp_fillval_tests.testfile"
  do i=1,num_iotypes
    PIO_TF_LOG(0,*) "Testing : PIO_TF_DATA_TYPE : ", iotype_descs(i)
    ierr = PIO_createfile(pio_tf_iosystem_, pio_file, iotypes(i), filename, PIO_CLOBBER) 
    PIO_TF_CHECK_ERR(ierr, "Could not create file " // trim(filename))

    ierr = PIO_def_dim(pio_file, 'PIO_TF_test_dim', dims(1), pio_dim)
    PIO_TF_CHECK_ERR(ierr, "Failed to define a dim : " // trim(filename))

    ierr = PIO_def_var(pio_file, 'PIO_TF_test_var', PIO_TF_DATA_TYPE, (/pio_dim/), pio_var)
    PIO_TF_CHECK_ERR(ierr, "Failed to define a var : " // trim(filename))

    ierr = PIO_enddef(pio_file)
    PIO_TF_CHECK_ERR(ierr, "Failed to end redef mode : " // trim(filename))

    ! Write the variable out
    call PIO_write_darray(pio_file, pio_var, iodesc, wbuf, ierr, BUF_FILLVAL)
    PIO_TF_CHECK_ERR(ierr, "Failed to write darray : " // trim(filename))

    call PIO_syncfile(pio_file)

    call PIO_read_darray(pio_file, pio_var, iodesc, rbuf, ierr)
    PIO_TF_CHECK_ERR(ierr, "Failed to read darray : " // trim(filename))

    PIO_TF_CHECK_VAL((rbuf, exp_val), "Got wrong val")

    call PIO_closefile(pio_file)
    call PIO_deletefile(pio_tf_iosystem_, filename)
  end do
  if(allocated(iotypes)) then
    deallocate(iotypes)
    deallocate(iotype_descs)
  end if

  call PIO_freedecomp(pio_tf_iosystem_, iodesc)
PIO_TF_AUTO_TEST_SUB_END nc_write_1d_explicit_fval

! nc write 1d array with fillvalues (the holes are implicit)
PIO_TF_TEMPLATE<PIO_TF_PREDEF_TYPENAME PIO_TF_DATA_TYPE, PIO_TF_PREDEF_TYPENAME PIO_TF_FC_DATA_TYPE>
PIO_TF_AUTO_TEST_SUB_BEGIN nc_write_1d_implicit_fval
  implicit none
  integer, parameter :: VEC_LOCAL_SZ = 7
  type(var_desc_t)  :: pio_var
  type(file_desc_t) :: pio_file
  character(len=PIO_TF_MAX_STR_LEN) :: filename
  type(io_desc_t) :: iodesc
  integer, dimension(:), allocatable :: compdof, compdof_rel_disps
  integer :: compdof_sz
  PIO_TF_FC_DATA_TYPE, dimension(:), allocatable :: wbuf
  PIO_TF_FC_DATA_TYPE, dimension(VEC_LOCAL_SZ) :: rbuf, exp_val
  ! The buffer fillvalue to be used when writing data
  PIO_TF_FC_DATA_TYPE, PARAMETER :: BUF_FILLVAL = -2
  integer, dimension(1) :: dims
  integer :: pio_dim
  integer :: i, ierr, lsz
  ! iotypes = valid io types
  integer, dimension(:), allocatable :: iotypes
  character(len=PIO_TF_MAX_STR_LEN), dimension(:), allocatable :: iotype_descs
  integer :: num_iotypes

  ! compdof is only specified for valid data values, the data holes are
  ! implicitly stated (by not specifying them rather than filling it with 0s)
  compdof_sz = min(pio_tf_world_rank_+1, VEC_LOCAL_SZ) 
  allocate(compdof(compdof_sz))
  allocate(wbuf(compdof_sz))
  allocate(compdof_rel_disps(compdof_sz))

  do i=1,compdof_sz
    compdof_rel_disps(i) = i
  end do
  dims(1) = VEC_LOCAL_SZ * pio_tf_world_sz_
  ! rank 0 has 1 valid data value, rank 2 has 2 data values and so on...
  compdof = VEC_LOCAL_SZ * pio_tf_world_rank_ + compdof_rel_disps

  wbuf = 0
  ! The first compdof_sz values, wbuf[1:compdof_sz], are valid in wbuf
  do i=1,compdof_sz
    wbuf(i) = compdof(i)
    exp_val(i) = wbuf(i)
  end do
  ! We expect the values (compdof_sz:VEC_LOCAL_SZ] to be read as 
  ! user specified fill values
  do i=compdof_sz+1,VEC_LOCAL_SZ
    exp_val(i) = BUF_FILLVAL
  end do
  rbuf = 0

  call PIO_initdecomp(pio_tf_iosystem_, PIO_TF_DATA_TYPE, dims, compdof, iodesc)

  num_iotypes = 0
  call PIO_TF_Get_nc_iotypes(iotypes, iotype_descs, num_iotypes)
  filename = "test_pio_decomp_fillval_tests.testfile"
  do i=1,num_iotypes
    PIO_TF_LOG(0,*) "Testing : PIO_TF_DATA_TYPE : ", iotype_descs(i)
    ierr = PIO_createfile(pio_tf_iosystem_, pio_file, iotypes(i), filename, PIO_CLOBBER) 
    PIO_TF_CHECK_ERR(ierr, "Could not create file " // trim(filename))

    ierr = PIO_def_dim(pio_file, 'PIO_TF_test_dim', dims(1), pio_dim)
    PIO_TF_CHECK_ERR(ierr, "Failed to define a dim : " // trim(filename))

    ierr = PIO_def_var(pio_file, 'PIO_TF_test_var', PIO_TF_DATA_TYPE, (/pio_dim/), pio_var)
    PIO_TF_CHECK_ERR(ierr, "Failed to define a var : " // trim(filename))

    ierr = PIO_enddef(pio_file)
    PIO_TF_CHECK_ERR(ierr, "Failed to end redef mode : " // trim(filename))

    ! Write the variable out, user specified fillvalue = BUF_FILLVAL
    call PIO_write_darray(pio_file, pio_var, iodesc, wbuf, ierr, BUF_FILLVAL)
    PIO_TF_CHECK_ERR(ierr, "Failed to write darray : " // trim(filename))

    call PIO_syncfile(pio_file)

    call PIO_read_darray(pio_file, pio_var, iodesc, rbuf, ierr)
    PIO_TF_CHECK_ERR(ierr, "Failed to read darray : " // trim(filename))

    PIO_TF_CHECK_VAL((rbuf, exp_val), "Got wrong val")

    call PIO_closefile(pio_file)
    call PIO_deletefile(pio_tf_iosystem_, filename)
  end do
  if(allocated(iotypes)) then
    deallocate(iotypes)
    deallocate(iotype_descs)
  end if

  call PIO_freedecomp(pio_tf_iosystem_, iodesc)
  deallocate(wbuf)
  deallocate(compdof)
  deallocate(compdof_rel_disps)
PIO_TF_AUTO_TEST_SUB_END nc_write_1d_implicit_fval
