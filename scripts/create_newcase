#!/usr/bin/env perl 
#-----------------------------------------------------------------------------------------------
#
# create_newcase
#
# This utility allows the users to specify configuration
# options via a commandline interface.
#
#-----------------------------------------------------------------------------------------------

use strict;
use English;
use Getopt::Long;
use Cwd qw( getcwd abs_path chdir);
use IO::File;
use IO::Handle;
use Data::Dumper;
use File::Basename;
use File::Path qw(mkpath);

# Check for the existence of XML::LibXML in whatever perl distribution happens to be in use.  
# If not found, print a warning message then exit. 
eval {
    require XML::LibXML;
    XML::LibXML->import();
};
if($@)
{
    my $warning = <<END;
WARNING:
    The perl module XML::LibXML is needed for XML parsing in the CESM script system.  
	Please contact your local systems administrators or IT staff and have them install it for 
	you, or install the module locally.  

END
	print "$warning\n";
    exit(1);
}

#-----------------------------------------------------------------------------------------------
# Setting autoflush (an IO::Handle method) on STDOUT helps in debugging.  It forces the test
# descriptions to be printed to STDOUT before the error messages start.
*STDOUT->autoflush();                  

#-----------------------------------------------------------------------------------------------
# Set the directory that contains the CESM configuration scripts.  If the create_newcase command was
# issued using a relative or absolute path, that path is in $ProgDir.  Otherwise assume the
# command was issued from the current working directory.

(my $ProgName = $0) =~ s!(.*)/!!;      # name of this script
my $ProgDir = $1;                      # name of directory containing this script -- may be a
                                       # relative or absolute path, or null if the script is in
                                       # the user's PATH
my $cwd = getcwd();                    # current working directory
my $cfgdir;                            # absolute pathname of directory that contains this script
if ($ProgDir) { 
    $cfgdir = abs_path($ProgDir);
} else {
    $cfgdir = $cwd;
}

my $cimeroot = abs_path("$cfgdir/../");
(-d "$cimeroot")  or  die <<"EOF";
** Cannot find cimeroot directory \"$cimeroot\" **
EOF

#-----------------------------------------------------------------------------------------------
if ($#ARGV == -1) {
    usage();
}
#-----------------------------------------------------------------------------------------------

sub usage {
    die <<EOF;

SYNOPSIS
  create_newcase [options]

OPTIONS
  User supplied values are denoted in angle brackets (<>).  Any value that contains
  white-space must be quoted.  Long option names may be supplied with either single
  or double leading dashes.  A consequence of this is that single letter options may
  NOT be bundled.

  -case <name>             Specifies the case name (required).
  -compset <name>          Specify a CESM compset (required).
  -res <name>              Specify a CESM grid resolution (required).
  -mach <name>             Specify a CESM machine (required).
  -pes_file <name>         Full pathname of pes file to use (will overwrite default settings) (optional)
  -project <name>          Specify a project id for the case (optional)
                           default: user-specified environment variable PROJECT or ACCOUNT
                                    or read from ~/.cesm_proj or ~/.ccsm_proj
  -compiler <name>         Specify a compiler for the target machine (optional)
                           default: default compiler for the target machine
  -mpilib <name>           Specify a mpi library for the target machine (optional)
                           default: default mpi library for the target machine
                           allowed: openmpi, mpich, ibm, mpi-serial, etc
                                    redundant with _M confopts setting
  -mach_dir <path>         Specify the locations of the Machines directory (optional).
                           default: \$cimeroot/machines
  -user_mods_dir <path>    Path to directory with user_nl_* files and xmlchange
                           commands to utilize (optional). For non-test cases, this 
                           can also include SourceMods
  -confopts <value>        Specify some additional configuration options (optional) as follows:
                           _AOA  = aoflux on atm grid
                           _AOE  = aoflux on exch grid
                           _CG   = gregorian calendar
                           _D    = debug
                           _E    = esmf interfaces
                           _IOP* = PnetCDF IO test where * is  A(atm), C(cpl), G(glc), 
                                   I(ice), L(lnd), O(ocn), W(wav) or blank (all components)
                           _L*   = set run length y, m, d, h, s, n(nsteps) plus integer 
                                   (ie _Lm6 for 6 months) 
                           _M*   = set the mpilib where * is default, mpi-serial, mpich, etc
                           _N*   = set NINST_ env value to * where * is an integer
                           _P*   = set pecount to specific values include 
                                   T,S,M,L,X,1,1x1,16,16x1,4x4,16x1D, etc
  -petype  <name>          Valid values are [threaded | mpionly] 
                           Force pes to be all threaded or all mpi
			   default: this is not set
  -pecount <name>          Value of S,M,L,X1,X2 (optional). 
                           default: M, partially redundant with confopts _P
  -user_compset <name>     Long name for new user compset to use (optional)
                           This assumes that all of the compset settings in the 
                           long name have been defined in cimeconfig/compsets.xml
  -user_grid_file <name>   Full pathname of grid file to use (optional)
                           This should be a "copy" of cimeconfig/grids.xml
                           with the new user grid changes added to it
  -help [or -h]            Print usage to STDOUT (optional).
  -testlist                List valid values for tests [normally only invoked by create_test] (optional).
  -silent [or -s]          Turns on silent mode - only fatal messages issued (optional).
  -verbose [or -v]         Turn on verbose echoing of settings made by create_newcase (optional).
  -xmlmode <name>          Sets format of xml files; normal or expert (optional). (default is normal) 
  -nowarning               Turns off checking of the known_problems repository. (default is on)
  -sharedlibroot           Used for re-using build components when building multiple CESM cases, 
                           default is \$EXEROOT

EXAMPLES

  #  ./create_newcase -case mycase1 -res f19_g16 -compset B1850CN -mach yellowstone
  #  ./create_newcase -case mycase2 -res f19_g16 -compset B1850CN -mach yellowstone -confopts _D_P16
  #  ./create_newcase -case mycase5 -res f19_g16 -compset B1850CN -mach yellowstone -confopts _CG_E -pes_file mypes_file

EOF
}

#-----------------------------------------------------------------------------------------------
# Save commandline
my $commandline = "create_newcase @ARGV";

#-----------------------------------------------------------------------------------------------
# Parse command-line options.
my %opts = (
    mach_dir => "$cimeroot/machines",
    user_mods_dir => undef,
    );
GetOptions(
    "case=s"                    => \$opts{'case'},
    "compset=s"                 => \$opts{'compset'},
    "confopts=s"                => \$opts{'confopts'},
    "project=s"                 => \$opts{'project'},  
    "compiler=s"                => \$opts{'compiler'},  
    "mpilib=s"                  => \$opts{'mpilib'},  
    "res=s"                     => \$opts{'res'},
    "h|help"                    => \$opts{'help'},
    "mach=s"                    => \$opts{'mach'},
    "mach_dir=s"                => \$opts{'mach_dir'},
    "user_mods_dir=s"           => \$opts{'user_mods_dir'},
    "pecount=s"                 => \$opts{'pecount'},
    "petype=s"                  => \$opts{'petype'},
    "pes_file=s"                => \$opts{'pes_file'}, 
    "user_grid_file=s"          => \$opts{'user_grid_file'},
    "s|silent"                  => \$opts{'silent'},
    "testname=s"                => \$opts{'testname'},
    "testlist"                  => \$opts{'testlist'},
    "v|verbose"                 => \$opts{'verbose'},
    "xmlmode=s"                 => \$opts{'xmlmode'},
    "nowarning"                 => \$opts{'nowarning'},
    "user_compset=s"            => \$opts{'user_compset'},
    "sharedlibroot=s"           => \$opts{'sharedlibroot'},
    )  or usage();

# Give usage message.
usage() if $opts{'help'};

# Check for unparsed argumentss
if (@ARGV) {
    print "ERROR: unrecognized arguments: @ARGV\n";
    usage();
}

#-----------------------------------------------------------------------------------------------
# Add $cfgdir/perl5lib to the list of paths that Perl searches for modules
my @dirs = ("$cfgdir", "$cimeroot/scripts/Tools", "$cimeroot/utils/perl5lib");
unshift @INC, @dirs;
require ConfigCase;
require ConfigCompsetGrid;
require ConfigPes;
require ConfigMachine;
require ConfigTests;
require ConfigCESM;
require ProjectTools;
require UserModsTools;
require Testing::TestLists; 

# Global variables
my $case;
my $caseroot; # set in _check_input_options
my $compset;  # set in _check_input_options
my $grid;     # set in _check_input_options
my $compiler; # set in _check_input_options
my $confopts; # set in _set_confopts 
my $machine;
my $testname;
my $pecount;
my $petype;
my $xmlmode;
my $project;
my $mpilib;
my $header_file;
my $sysmod;

# Define 3 print levels:
# 0 - only issue fatal error messages
# 1 - only informs what files are created (default)
# 2 - verbose
my $print = 1;
if ($opts{'silent'})  { $print = 0; }
if ($opts{'verbose'}) { $print = 2; }

if ($print>=2) { print "Setting configuration directory to $cfgdir\n"; }

#------------------------------------------------------------------------------------------
# *** Check input
#------------------------------------------------------------------------------------------
# Note that check_input_options will use the global hash opts
_check_input_options (\%opts);

#------------------------------------------------------------------------------------------
# *** Determine user_mods_dir
#------------------------------------------------------------------------------------------
my $user_mods_dir = $opts{'user_mods_dir'};
if ($user_mods_dir) {
    (-d "$user_mods_dir") or  die "** Cannot find user_mods_dir directory $user_mods_dir **"
}

#------------------------------------------------------------------------------------------
# *** Create empty new config object ***
#------------------------------------------------------------------------------------------
my $cfg_ref = ConfigCase->new("");

#------------------------------------------------------------------------------------------
# *** Create all values in $cfg_ref that are not component specific
#------------------------------------------------------------------------------------------
# The following file determines all non-component specific file and directory variables
# that will be added to $cfg_ref
my $file = "$cimeroot/scripts/cimeconfig/files_spec.xml";

# Read the general specification file and add to $cfg_ref each variable in that file
my $srcroot  = "$cimeroot/../"; #TODO - this needs to be generalized
my $username = "$ENV{'USER'}";  #TODO - change ccsmuser to username

$cfg_ref->add_file_general_spec_variables($file, $cimeroot, $srcroot, $caseroot);

# For each $cfg_ref variable that points to a file that has a "DEFINITION_" prefix,
# open that file and add all of those variables to $cfg_ref
foreach my $id (keys %$cfg_ref) {
    if ($id =~ m/^DEFINITIONS_/) {
	my $file = $cfg_ref->get($id);
	$cfg_ref->add_config_variables($file);
    }
}

# Overwrite the non-default values for the following cfg_ref elements (needed for the calls below)
$cfg_ref->set('CCSMUSER'	  , "$username");
$cfg_ref->set('USER'	          , "$username");
$cfg_ref->set('CASEROOT'	  , "$caseroot");
$cfg_ref->set('CASETOOLS'         , "$caseroot/Tools");
$cfg_ref->set('CASEBUILD'         , "$caseroot/Buildconf");
$cfg_ref->set('CASE'		  , "$case");
$cfg_ref->set('CIMEROOT'	  , "$cimeroot");
$cfg_ref->set('UTILROOT'	  , "$cimeroot/scripts/Tools");
$cfg_ref->set('SRCROOT'		  , "$srcroot");
$cfg_ref->set('CCSMROOT'	  , "$cimeroot/../"); #TODO - deprecate CCSMROOT = put out message

#------------------------------------------------------------------------------------------
# *** Determine grid specification file
#------------------------------------------------------------------------------------------
my $grids_dir;
if (defined $opts{'user_grid_dir'}){
    # Determine file specifying set of supported model grids
    $grids_dir = $opts{'user_grid_dir'};
    (-d $grids_dir)  or  die "** Cannot find user specified grid directory $grids_dir **\n";
    my $grids_file = "$grids_dir/grids.xml";
    (-f "$grids_file")  or  die "** Cannot find user specified grids file $grids_file **\n";
    $cfg_ref->set('GRIDS_DIR', "$grids_dir");
} else {
    $grids_dir = $cfg_ref->get('GRIDS_DIR');
    (-d "$grids_dir")  or  die "** Cannot find grids dir $grids_dir ***\n";
}    
my $file = "$grids_dir" . '/' . "grids.xml";
$cfg_ref->set('GRIDS_SPEC_FILE', "$file");

#------------------------------------------------------------------------------------------
# *** Options for listing (exit after listing) 
#------------------------------------------------------------------------------------------
if ($opts{'testlist'}) {
    my $tests_file = $cfg_ref->get('TESTS_SPEC_FILE');
    ConfigTests::listTests("$tests_file");
    exit;
}    

#------------------------------------------------------------------------------------------
# *** Read the file that determines the possible compsets 
#------------------------------------------------------------------------------------------
# The following file now replaces what used to be config_compsets.xml
# Each primary component is responsible for defining the compsets that turn of the
# appropriate feedbacks for development of that component
my $file = "$cimeroot/scripts/cimeconfig/files_spec.xml";

# First determine primary component (for now this is only CESM specific)
my $primary_component;
if (! $opts{'compset'}) {
    die "ERROR: must set the -compset option to create_newcase \n";
}
$primary_component = ConfigCESM::getPrimaryComponent($compset);

# Now given the primary component, read the xml file that determines the full pathname
# of the file that defines the compsets for this primary component
# Note - the value of the cfg_ref variable 'COMPSETS_SPEC_FILE' gives the full pathname of the
# file containing the possible out of the box compsets that can be used by create_newcase
$cfg_ref->add_file_compset_spec_variables($file, $cimeroot, $srcroot, $primary_component);

my $compsets_file = $cfg_ref->get('COMPSETS_SPEC_FILE');

print "Component that specifies compsets is $primary_component \n";
print "File that specifies possible compsets is $compsets_file \n";

#------------------------------------------------------------------------------------------
# *** Determine the full pathnames of all definition files for each compset component
#------------------------------------------------------------------------------------------
# A few notes for clarification:
# all possible compset components will contain the file 
#      'definitions_component.xml
# that specify the xml variable definitions for that component 
# to obtain the directory containing the definitions_variable.xml file 
# for the atmospheric component you would use
#     my $file = $cfg_ref->get('CIMECONFIG_ATM_FILE');
# if the atmopsheric component was datm, then $file would be
#     $cimeroot/components/data_comps/datm/cimeconfig/definitions_component.xml
# note that for CESM, the only primary components are
#     cam, clm, cice, cism, pop, drv, allactive
# so the directories for the primary components will contain the additional two files:
#     'compsets.xml' and 'pelayouts.xml'   

# First determine compset longname TODO: remove redundancy of support level

my ($compset_longname, $compset_aliasname, $support_level) = 
    ConfigCompsetGrid::getCompsetLongname($compsets_file, $compset, $opts{'user_compset'});  
$cfg_ref->set('COMPSET', "$compset_longname"); 

# Next determine compset components given compset longname
my @compset_components = ('drv');
$compset_longname =~ m/(^\w\w\w\w\w)(.+)/; # remove the first date specified from the compset
my $components = $2;
my @elements = split /_/, $components;
foreach my $element (@elements) {
    my @element_components = split /%/, $element;
    my $component = lc $element_components[0];
    if ($component =~ m/\d+/) {
	$component =~ s/\d//g;
    }
    push (@compset_components, $component);
}

# Finally, given the compset components, determine the full pathname of each compset
# component xml variable definition file (all have the generic name definitions_component.xml) 
# and the directories each component's buildlib and buildnml files
my $file = "$cimeroot/scripts/cimeconfig/files_spec.xml";
foreach my $component (@compset_components) {
    $cfg_ref->add_file_component_spec_variables($file, $cimeroot, $srcroot, $component);
}

#------------------------------------------------------------------------------------------
# *** Determine grid longname 
#------------------------------------------------------------------------------------------
# First determine the grid longname and alias 
my ($grid_longname, $grid_shortname, $grid_aliasname, $compset_match ) = 
    ConfigCompsetGrid::getGridLongname($cfg_ref, $grid); 
$cfg_ref->set('GRID', "$grid_longname");

# Check if the grid and compset consistent - TODO put this logic back in getGridLongname
if ($compset_match) {
    # if there is a compset attribute, does the compset longname 
    if ($compset_longname !~ /$compset_match/) {
	die " ERROR: no supported match for primary grid $grid and primary compset-match $compset_match \n";
    }
}


#------------------------------------------------------------------------------------------
# *** Determine the cfg_ref variables for the specified compset and grid  ***
#------------------------------------------------------------------------------------------
# this will overwrite default values
ConfigCompsetGrid::setCompsetGrid($print, $cfg_ref);

#------------------------------------------------------------------------------------------
# *** Inform the user of the current support level for the compset they are attempting to run.
#------------------------------------------------------------------------------------------
my $testsforcase;
if ( $opts{'compset'} ) {
   my %case;
   $case{'compset'} = $opts{'compset'};
   $case{'grid'} = $opts{'res'};
   #   my $testlistobj = Testing::TestLists->new(scriptsdir => $cfgdir); TODO
   #   $testsforcase = $testlistobj->findTestsForCase(\%case); TODO
} else {
   $testsforcase = "WARNING!:: User compset names are NOT tested by the standard CESM process.\n" .
                   "           Thus you may likely find that this configuration will NOT work.\n" .
                   "           And you are completely on your own to figure out how to get it working.";
}
my $banner = '-' x 80;
# print "$banner\n";
if ( defined($support_level) ) {
   print "Compset and grid support levels for this case are:\n";
   print "$support_level\n";
}
print "$testsforcase\n";
# print "$banner\n";

#------------------------------------------------------------------------------------------
# *** Determine machines file specifying set of out-of-the box machines and then
#     set the machine parameters, including compilers
#------------------------------------------------------------------------------------------
ConfigMachine::setMachineValues($machine, $compiler, $print, $cfg_ref);

#------------------------------------------------------------------------------------------
# *** Set the testname parameters
#------------------------------------------------------------------------------------------
if (defined $opts{'testname'}) {
    $testname = $opts{'testname'};
    _set_test("$cfgdir/Testing/Testcases/config_tests.xml", $testname, $cfg_ref);
}

#------------------------------------------------------------------------------------------
# *** Set the input configure options if appropriate and also some additional $cfg_ref variables
#------------------------------------------------------------------------------------------
if (defined $opts{'confopts'}) {
    $confopts = $opts{'confopts'};
    _set_confopts($confopts, $cfg_ref);
}

#------------------------------------------------------------------------------------------
# *** Set the project id
# Check for optional project; if not given, see if we can find a project to use
#------------------------------------------------------------------------------------------
if ($opts{'project'}) {
   $project = $opts{'project'};
}
else {
   $project = ProjectTools::find_project();
}

if ($cfg_ref->get('PROJECT_REQUIRED') eq "TRUE") {
    ProjectTools::check_project_required_but_unset($project);
}
if (ProjectTools::set_project($project)) {
    $cfg_ref->set('PROJECT', $project);
} 

#------------------------------------------------------------------------------------------
# *** Set the case pe-layout
#------------------------------------------------------------------------------------------
ConfigPes::setPes($pecount, $compset_longname, $machine, $cimeroot, $primary_component, \%opts, $cfg_ref);

#------------------------------------------------------------------------------------------
# *** Set the mpi library and the repotag
#------------------------------------------------------------------------------------------
_set_mpi_library($mpilib, $cfg_ref);
_set_repotag($cimeroot, $cfg_ref);

#------------------------------------------------------------------------------------------
# *** Set the sharedlibroot for building shared CESM components
#------------------------------------------------------------------------------------------
if (defined $opts{'sharedlibroot'}) {
    $cfg_ref->set('SHAREDLIBROOT', $opts{'sharedlibroot'});
}

#------------------------------------------------------------------------------------------
# *** Create the caseroot directory tree and all caseroot required files
#------------------------------------------------------------------------------------------

# create the caseroot directory and necessary subdirectories
_create_caseroot($caseroot, $cimeroot, $cfg_ref);

# Copy the user_mods_dir files in and apply them
if ( defined($user_mods_dir) ) {
   my $is_test = 0;
   if ($testname) {$is_test = 1;}
   UserModsTools::apply_mods($user_mods_dir, $caseroot, $print, $is_test);
}

#------------------------------------------------------------------------------------------
# finish
#------------------------------------------------------------------------------------------
if ($print) {print "Successfully created the case for $machine \n";}
if ($print>=2) { print "create_xml done.\n"; }
exit 0;

#-----------------------------------------------------------------------------------------------
#                               Private routines
#-----------------------------------------------------------------------------------------------
sub _check_input_options
{

    if (!$opts{'testlist'}) {
	# Check for manditory case input
	if ($opts{'case'}) {
	    $case = $opts{'case'};
	} else {
	    die "ERROR: create_newcase must include the input argument, -case \n";
	}
	if (-d $case) {
	    die "Case directory $case already exists \n";
	}
	mkpath($case); 
	$caseroot = abs_path("$case");

	my @dirs = split "/", $caseroot, -1;  # The -1 prevents split from stripping trailing nulls
	my $num = scalar @dirs;
	$case = $dirs[$num-1];

	# Check for manditory compset input
	if ($opts{'compset'}) {
	    $compset = $opts{'compset'};
	} else {
	    if (!$opts{'user_compset'}) {
		die "ERROR: create_newcase must include the input argument, -compset or user_compset\n";
	    }
	}
	# Check for mandatory grid input
	if ($opts{'res'}) {
	    $grid = $opts{'res'};
	} else {
	    die "ERROR: create_newcase must include the input argument, -res\n";
	}
	# Check for manditory machine input
	if ($opts{'mach'}) {
	    $machine = $opts{'mach'};
	} else {
	    die "ERROR: create_newcase must include the input argument, -mach \n";
	}
	# Check if machine compiler option is given
	if ($opts{'compiler'}) {
	    $compiler = $opts{'compiler'};
	}
	# Check if machine mpilib option is given
	$mpilib = 'unset';
	if ($opts{'mpilib'}) {
	    $mpilib = $opts{'mpilib'};
	}
	# Check for pecount setting
	$pecount = 'M';
	if ($opts{'pecount'}) {
	    $pecount = $opts{'pecount'};
	}
	# Check for xmlmode setting
	$xmlmode = 'normal';
	if ($opts{'xmlmode'}) {
	    $xmlmode = $opts{'xmlmode'};
	}
    }
}

#-------------------------------------------------------------------------------
sub _define_cfg_elements
{
    my ($cimeroot, $opts_ref, $primary_component, $cfg_ref) = @_;
}

#-------------------------------------------------------------------------------
sub _set_confopts
{
    # Print all currently supported valid grids

    my ($coptions, $cfg_ref) = @_;

    print "  confopts = $coptions\n";
    if ($coptions =~ "_D" || $coptions =~ "_ED") {
	$cfg_ref->set('DEBUG', "TRUE");
	print "    confopts DEBUG ON \n";
    }
    if ($coptions =~ "_E" || $coptions =~ "_DE") {
	$cfg_ref->set('USE_ESMF_LIB', "TRUE");
	$cfg_ref->set('COMP_INTERFACE', "ESMF");
	print "    confopts COMP_INTERFACE ESMF set \n";
    }

    if ($coptions =~ "_P") {
	my $popt = $coptions;
	$popt =~ s/.*_P([A-Za-z0-9]*)_?.*/$1/;
	$pecount = $popt;
	print "    confopts pecount set to $pecount \n";
    }
    if ($coptions =~ "_M") {
	my $mopt = $coptions;
	$mopt =~ s/.*_M([A-Za-z0-9\-]*)_?.*/$1/;
	$mpilib = $mopt;
	print "    mpilib set to $mpilib \n";
    }
    if ($coptions =~ "_L") {
	my $lopt = $coptions;
	$lopt =~ s/.*_L([A-Za-z0-9]*)_?.*/$1/;
	my $loptc = substr($lopt,0,1);
	my $lopti = substr($lopt,1);
	my $lopts = 'unknown';
	if ($loptc =~ "y") {$lopts = 'nyears'}
	if ($loptc =~ "m") {$lopts = 'nmonths'}
	if ($loptc =~ "d") {$lopts = 'ndays'}
	if ($loptc =~ "h") {$lopts = 'nhours'}
	if ($loptc =~ "s") {$lopts = 'nseconds'}
	if ($loptc =~ "n") {$lopts = 'nsteps'}
	if ($lopts =~ "unknown") {
	    print "$0 _L confopts run length undefined, only y m d h s n allowed\n\n";
	    exit -1;
	}
	$cfg_ref->set('STOP_OPTION', $lopts);
	$cfg_ref->set('STOP_N', $lopti);
	print "    confopts run length set to $lopt . $lopts . $lopti \n";
    }
    if ($coptions =~ "_N") {
	my $nopt = $coptions;
	$nopt =~ s/.*_N([0-9]*)_?.*/$1/;
	$cfg_ref->set('NINST_ATM', $nopt);
	$cfg_ref->set('NINST_LND', $nopt);
	$cfg_ref->set('NINST_OCN', $nopt);
	$cfg_ref->set('NINST_ICE', $nopt);
	$cfg_ref->set('NINST_GLC', $nopt);
	$cfg_ref->set('NINST_ROF', $nopt);
	$cfg_ref->set('NINST_WAV', $nopt);
	print "    confopts instances set to $nopt \n";
    }
    if ($coptions =~ "_CG") {
	$cfg_ref->set('CALENDAR', "GREGORIAN");
	print "    confopts CALENDAR set to GREGORIAN \n";
    }
    if ($coptions =~ "_AOA") {
	$cfg_ref->set('AOFLUX_GRID', "atm");
	print "    confopts AOFLUX_GRID set to atm \n";
    }
    if ($coptions =~ "_AOE") {
	$cfg_ref->set('AOFLUX_GRID', "exch");
	print "    confopts AOFLUX_GRID set to exch \n";
    }
}

#-------------------------------------------------------------------------------
sub _set_mpi_library
{
    # set the mpi library, $mpilib
    # $mpilib can be set by -mpilib, confopts, or automatically
    # precedent is confopts, mpilib, automatic, default

    my ($mpilib, $cfg_ref) = @_;

    my $mpilibs = $cfg_ref->get('MPILIBS');
    my @mpilibs = split ",", $mpilibs, -1;

    if ($mpilib =~ 'unset') 
    {
	if ($cfg_ref->get('NTASKS_ATM') == 1 && $cfg_ref->get('NTASKS_LND') == 1 &&
	    $cfg_ref->get('NTASKS_OCN') == 1 && $cfg_ref->get('NTASKS_ICE') == 1 &&
	    $cfg_ref->get('NTASKS_ROF') == 1 && $cfg_ref->get('NTASKS_GLC') == 1 &&
	    $cfg_ref->get('NTASKS_WAV') == 1 && $cfg_ref->get('NTASKS_CPL') == 1) 
	{ 
	    $mpilib = "mpi-serial"; 
	}
    }
    if ( $mpilib =~ 'default' || $mpilib =~ m/^\s*$/ ) {
	$mpilib = $mpilibs[0];
    }
    if (! ($mpilib =~ 'unset')) {
	my $found = 0;
	foreach my $mpi (@mpilibs) {
	    if ($mpilib eq $mpi) {
		$found = 1;
	}
	}
	if (!$found) {
	    $sysmod = "rm -rf $caseroot";
	    system($sysmod) == 0 or die "ERROR: $sysmod failed: $?\n";
	    die "ERROR: mpilib setting of $mpilib does not match supported values of $mpilibs \n";
	}
    } else {
	if ($machine =~ /userdefined/){
	    $mpilib = "USERDEFINED_required_build";
	}else{
	    $mpilib = $mpilibs[0];
	}
    }    
    $cfg_ref->set('MPILIB', "$mpilib");
    if ($print>=2) { print "Machine mpilib specifier: $mpilib.\n"; }
}

#-------------------------------------------------------------------------------
sub _set_repotag 
{
    my ($cimeroot, $cfg_ref) = @_; 

    my $repotag;
    if (-f "$cimeroot/ChangeLog") { 
	$repotag =`cat $cimeroot/ChangeLog | grep 'Tag name:' | head -1`;
    }
    my @repotag = split(/ /,$repotag); 
    $repotag = $repotag[2]; 
    chomp($repotag);
    $cfg_ref->set('CCSM_REPOTAG', $repotag);
}

#-------------------------------------------------------------------------------
sub _create_caseroot
{
    # Create caseroot directory and all necessary sub directories
    my ($caseroot, $cimeroot, $cfg_ref) = @_;

    print "Creating $caseroot \n";
    mkdir ("$caseroot");
    chdir ("$caseroot");

    my $scriptsroot = "$cimeroot/scripts";

    # Create relevant directories in $caseroot
    my @newdirs = qw(. SourceMods LockedFiles Buildconf Tools);
    foreach my $newdir ( @newdirs ) {
	mkpath($newdir); 
    }

    # Open a new README.case file in $caseroot
    my $file = "$caseroot/README.case";
    my $fh = IO::File->new($file, '>' ) or die "can't open file: $file\n";
    print $fh "$commandline\n\n\n";
    $fh->close;

    # print README/disclaimer file in scripts dir
    $sysmod = "cp $scriptsroot/README $caseroot/README.science_support";
    system($sysmod) == 0 or die "ERROR: $sysmod failed: $?\n";

    _create_caseroot_sourcemods($caseroot, $cimeroot, $cfg_ref);  
    _create_caseroot_tools ($caseroot, $scriptsroot);
    _create_caseroot_buildconf($caseroot, $cimeroot, $cfg_ref);  
    _create_caseroot_files($case, $caseroot, $cimeroot, $scriptsroot, $machine, $compiler, $print, $cfg_ref);
}

#-------------------------------------------------------------------------------
sub _create_caseroot_tools
{
    # Copy relevant files into $caseroot
    my ($caseroot, $scriptsroot) = @_;
    
    $sysmod;

    my @files = (
	"$scriptsroot/Tools/cesm_setup", 
	"$scriptsroot/Tools/testcase_setup", 
	"$scriptsroot/Tools/check_input_data", 
	"$scriptsroot/Tools/archive_metadata.sh", 
	"$scriptsroot/Tools/check_case", 
	"$scriptsroot/Tools/create_production_test", 
	"$scriptsroot/Tools/xmlchange",
	"$scriptsroot/Tools/xmlquery",
	"$scriptsroot/Tools/st_archive", 
	"$scriptsroot/Tools/README.post_process", 
	); 
    foreach my $file (@files) {
	$sysmod = "cp -p $file $caseroot"; 
	system($sysmod) == 0 or die "ERROR: $sysmod failed: $?\n";
    }
    $sysmod = "chmod u+w $caseroot/create_production_test";
    system($sysmod) == 0 or die "ERROR: $sysmod failed: $?\n";
    
    my $machines_file = $cfg_ref->get('MACHINES_SPEC_FILE');
    my $machines_dir  = dirname($machines_file);

    my $mkbatch = "$ENV{'HOME'}/.cime/mkbatch.$machine";
    if (! -f "$mkbatch") {
	$mkbatch = "$machines_dir/mkbatch.$machine";
    } else {
	print "\nUsing UNSUPPORTED userdefined mkbatch script: \"~/.cime/mkbatch.$machine\"\n";
    }
    
    # Copy relevant files into $caseroot/Tools/
    @files = ("$scriptsroot/cimeconfig/archive.xml",
	      "$scriptsroot/cimeconfig/archive.xsd",
	      "$scriptsroot/Tools/cesm_buildnml", 
	      "$scriptsroot/Tools/cesm_prestage", 
	      "$scriptsroot/Tools/cesm_prerun_setup", 
	      "$scriptsroot/Tools/cesm_postrun_setup", 
	      "$scriptsroot/Tools/check_lockedfiles", 
	      "$scriptsroot/Tools/lt_archive.sh", 
	      "$scriptsroot/Tools/st_archive", 
	      "$scriptsroot/Tools/getTiming", 
	      "$scriptsroot/Tools/SetupTools.pm",
	      "$scriptsroot/Tools/ProjectTools.pm",
	      "$scriptsroot/Tools/ConfigCase.pm",
	      "$scriptsroot/Tools/compare_namelists.pl",
	      "$machines_dir/ccsm_getenv", 
	      "$machines_dir/taskmaker.pl", 
	      "$machines_dir/Makefile",
	      "$machines_dir/mkSrcfiles", 
	      "$machines_dir/mkDepends"); 
	      #"$mkbatch");
    
    foreach my $file (@files) {
	$sysmod = "cp -p $file $caseroot/Tools/. "; 
	system($sysmod) == 0 or die "ERROR: $sysmod failed: $?\n";
    }
}

#-------------------------------------------------------------------------------
sub _create_caseroot_files
{
    my ($case, $caseroot, $cimeroot, $scriptsroot, $machine, 
	$compiler, $print, $cfg_ref) = @_;

    my $machines_file = $cfg_ref->get('MACHINES_SPEC_FILE');
    my $machines_dir  = dirname($machines_file);
    my $mkbatch_file = "$ENV{'HOME'}/.cime/mkbatch.$machine";
    if (! -f "$mkbatch_file") {
	$mkbatch_file = "$machines_dir/mkbatch.$machine";
    } else {
	print "\nUsing UNSUPPORTED userdefined mkbatch script: \"~/.cime/mkbatch.$machine\"\n";
    }

    # Create $case.build
    $sysmod = "cp $scriptsroot/Tools/cesm_build.csh  $caseroot/$case.build";
    system ($sysmod); if ($? == -1) {die "$sysmod failed: $!\n";}
    $sysmod = "chmod 755 $caseroot/$case.build";
    system ($sysmod); if ($? == -1) {die "$sysmod failed: $!\n";}

    # Create $caseroot/Buildconf/cesm_build.pl
    $sysmod = "cp $scriptsroot/Tools/cesm_build.pl  $caseroot/Buildconf/cesm_build.pl";
    system ($sysmod); if ($? == -1) {die "$sysmod failed: $!\n";}

    $sysmod = "chmod 755 $caseroot/Buildconf/cesm_build.pl";
    system ($sysmod); if ($? == -1) {die "$sysmod failed: $!\n";}
    
    # Create $case.clean_build
    $sysmod = "cp $scriptsroot/Tools/cesm_clean_build $caseroot/$case.clean_build"; 
    system($sysmod) == 0 or die "ERROR: $sysmod failed: $?\n";
    
    # Create $case.submit
    $sysmod = "cp  $scriptsroot/Tools/cesm_submit $caseroot/$case.submit"; 
    system($sysmod) == 0 or die "ERROR: $sysmod failed: $?\n";

    # Create $case.l_archive
    #$sysmod = "env CCSMUSER=$username CASE=$case CASEROOT=$caseroot PROJECT=$project env PHASE=set_larch $mkbatch_file";
    #system($sysmod) == 0 or die "ERROR: $sysmod failed: $?\n";

    # Create $caseroot preview_namelist file
    my $file = "${caseroot}/preview_namelists"; 
    $sysmod = "cp  $scriptsroot/Tools/preview_namelists $file"; 
    system($sysmod) == 0 or die "ERROR: $sysmod failed: $?\n";

    $sysmod = "chmod 755 $file";
    system ($sysmod); if ($? == -1) {die "$sysmod failed: $!\n";}

    if (-e "$machines_dir/env_mach_specific.$machine" ) {
	$sysmod = "cp $machines_dir/env_mach_specific.$machine $caseroot/env_mach_specific";
	system($sysmod) == 0 or die "ERROR: $sysmod failed: $?\n";
    } else {
	$sysmod = "touch $caseroot/env_mach_specific";
	system($sysmod) == 0 or die "ERROR: $sysmod failed: $?\n";
    }

    if ( -e "$machines_dir/Depends.$machine" ) {
	$sysmod = "cp $machines_dir/Depends.$machine $caseroot/";
	system($sysmod) == 0 or die "ERROR: $sysmod failed: $?\n";
    }
    if ( -e "$machines_dir/Depends.$compiler" ) {
	$sysmod = "cp $machines_dir/Depends.$compiler $caseroot/";
	system($sysmod) == 0 or die "ERROR: $sysmod failed: $?\n";
    }

    # Create env_case.xml
    my  $caseheaders_file = $cfg_ref->get('CASEFILE_HEADERS');
    (-f $caseheaders_file) or die "ERROR: case header file $caseheaders_file does not exist \n";

    $cfg_ref->write_file("$caseroot/env_case.xml", "$caseheaders_file", $caseroot, $cimeroot );
    if ($print) {print "Created $caseroot/env_case.xml \n";}

    # Create env_mach_pes.xml.xml
    $cfg_ref->write_file("$caseroot/env_mach_pes.xml", "$caseheaders_file", $caseroot, $cimeroot );  
    if ($print) {print "Created $caseroot/env_mach_pes.xml \n";}

    # Create env_build.xml
    $cfg_ref->write_file("$caseroot/env_build.xml", "$caseheaders_file", $caseroot, $cimeroot );
    if ($print) {print "Created $caseroot/env_build.xml \n";}

    # Create env_run.xml
    $cfg_ref->write_file("$caseroot/env_run.xml", "$caseheaders_file", $caseroot, $cimeroot );
    if ($print) {print "Created $caseroot/env_run.xml \n";}

    # Create env_archive.xml
    $cfg_ref->write_file("$caseroot/env_archive.xml", "$caseheaders_file", $caseroot, , $cimeroot, 
			 "$cimeroot/scripts/cimeconfig/archive.xml");
    if ($print) {print "Created $caseroot/env_archive.xml \n";}

    # copy env_case.xml in to locked files
    $sysmod = "cp $caseroot/env_case.xml $caseroot/LockedFiles/env_case.xml.locked"; 
    system($sysmod) == 0 or die "ERROR: $sysmod failed: $?\n";
    if ($print) {print "Locking file $caseroot/env_case.xml \n";}

    # also create the CaseStatus file in $caseroot
    my $file = "$caseroot/CaseStatus";
    my $fh = IO::File->new($file, '>' ) or die "can't open file: $file\n";
    my $time = time;
    my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst)=localtime(time);
    $year = 1900+$year;
    $mon = 1+$mon;
    print $fh "$commandline\n";
    printf ($fh "case created %04u-%02u-%02u %02u:%02u:%02u\n",$year,$mon,$mday,$hour,$min,$sec);
}

#-------------------------------------------------------------------------------
sub _create_caseroot_buildconf
{
    my ($caseroot, $cimeroot, $cfg_ref) = @_;  

    my $dir_atm  = $cfg_ref->get("BLD_ATM_DIR"); 
    my $dir_lnd  = $cfg_ref->get("BLD_LND_DIR"); 
    my $dir_ocn  = $cfg_ref->get("BLD_OCN_DIR"); 
    my $dir_ice  = $cfg_ref->get("BLD_ICE_DIR"); 
    my $dir_glc  = $cfg_ref->get("BLD_GLC_DIR"); 
    my $dir_rof  = $cfg_ref->get("BLD_ROF_DIR"); 
    my $dir_wav  = $cfg_ref->get("BLD_WAV_DIR");

    my $sysmod;
    my $buildconf  = "$caseroot/Buildconf";
    my @bld_dirs = ($dir_atm, $dir_lnd, $dir_ocn, $dir_ice, $dir_glc, $dir_rof, $dir_wav); 
    foreach my $bld_dir (@bld_dirs) {
	$sysmod = "cp -p $bld_dir/*.buildlib $buildconf/.";
	system($sysmod) == 0 or die "ERROR: $sysmod failed: $?\n";

	$sysmod = "cp -p $bld_dir/*.buildnml $buildconf/.";
	system($sysmod) == 0 or die "ERROR: $sysmod failed: $?\n";
	
	# TODO: the following is CESM specific and should be move to the ConfigCESM.pm module
	if ($bld_dir =~ /cism/) {
	    $sysmod = "cp -p $bld_dir/cism.template $buildconf/.";
	    system($sysmod) == 0 or die "ERROR: $sysmod failed: $?\n";
	}
	if ($bld_dir =~ /cice/) {
	    $sysmod = "cp $bld_dir/generate_cice_decomp.pl $buildconf/."; 
	    system($sysmod) == 0 or die "ERROR: $sysmod failed: $?\n";
	}
	if ($bld_dir =~ /pop/) {
	    $sysmod = "cp $bld_dir/generate_pop_decomp.pl $buildconf/."; 
	    system($sysmod) == 0 or die "ERROR: $sysmod failed: $?\n";
	} 
    }

    # copy cpl.buildnml and cpl.buildexe into Buildconf/
    $sysmod = "cp -p $cimeroot/driver_cpl/bld/cpl.buildnml $buildconf/.";
    system($sysmod) == 0 or die "ERROR: $sysmod failed: $?\n";

    $sysmod = "cp -p $cimeroot/driver_cpl/bld/model.buildexe $buildconf/.";
    system($sysmod) == 0 or die "ERROR: $sysmod failed: $?\n";

    # copy external libraries buildlib.xxx into Buildconf/
    # ---TODO: this will need to be generalized when csm_share is split up

    my $machines_file = $cfg_ref->get('MACHINES_SPEC_FILE');
    my $machines_dir  = dirname($machines_file);
    foreach my $lib ("gptl", "mct", "csm_share", "pio") {
	$sysmod = "cp ${machines_dir}/buildlib.${lib} $buildconf/.";
	system($sysmod) == 0 or die "ERROR: $sysmod failed: $?\n";
    }
}


#-------------------------------------------------------------------------------
sub _create_caseroot_sourcemods
{
    my ($caseroot, $cimeroot, $cfg_ref) = @_;  

    my $comps_atm  = $cfg_ref->get("COMP_ATM"); 
    my $comps_lnd  = $cfg_ref->get("COMP_LND"); 
    my $comps_ocn  = $cfg_ref->get("COMP_OCN"); 
    my $comps_ice  = $cfg_ref->get("COMP_ICE"); 
    my $comps_glc  = $cfg_ref->get("COMP_GLC"); 
    my $comps_rof  = $cfg_ref->get("COMP_ROF"); 
    my $comps_wav  = $cfg_ref->get("COMP_WAV");
    my @comps  = ($comps_atm, $comps_lnd, $comps_ocn, $comps_ice, $comps_glc, $comps_rof, $comps_wav); 

    # Create sourcemods
    my $moddir = "$caseroot/SourceMods";
    foreach my $comp (@comps)  {
	mkpath("$moddir/src.$comp"); 
	# ---TODO: this is CESM specific given that we are referencing cism explitly
	# this logic should be moved to ConfigCESM.pm
	if ($comp eq 'cism') {
	    mkpath("$moddir/src.$comp/glimmer-cism");
	    open(README, ">", "$moddir/src.$comp/README") or
		die "cannot open > $moddir/src.$comp/README: $!";
	    print README
		"Put source mods for the glimmer-cism library in the glimmer-cism subdirectory.\n",
		"This includes any files that are in the glimmer-cism subdirectory of $cimeroot/../components/cism.\n\n",
		"Anything else (e.g., mods to source_glc or drivers) goes in this directory, NOT in glimmer-cism/.\n";
	    close(README);
	}
    }
    mkpath("$caseroot/SourceMods/src.share"); 
    mkpath("$caseroot/SourceMods/src.drv"); 
}

#-------------------------------------------------------------------------------
sub _set_test
{
    # Set the parameters for the specified testname.  The
    # parameters are read from an input file, and if no testname matches are
    # found then issue error message.
    # This routine uses the configuration defined at the package level ($cfg_ref).

    my ($test_file, $testname, $cfg_ref) = @_;

    my $parser = XML::LibXML->new( no_blanks => 1);
    my $xml = $parser->parse_file($test_file);
    my @nodes = $xml->findnodes(".//test[\@NAME=\"$testname\"]/*");
    if (@nodes) {
	foreach my $node (@nodes) {
	    my $id = $node->nodeName();
	    my $value = $node->textContent();
	    $cfg_ref->set($id, $value);
	}
    } else {
	print "_set_test: no match for test $testname - possible testnames are \n";
	@nodes = $xml->findnodes(".//test");
	foreach my $node (@nodes) {
	    my $name = $node->getAttribute('NAME');
	    my @child_nodes = $node->findnodes('./DESC');
	    my $desc = $child_nodes[0]->textContent();
	    print " $name ($desc) \n" ;
	}
	die "_set_test: exiting\n"; 
    }
}

#-------------------------------------------------------------------------------
sub _clean
{
    my ($name) = @_;
    
    $name =~ s/^\s+//; # strip any leading whitespace 
    $name =~ s/\s+$//; # strip any trailing whitespace
    return ($name);
}


