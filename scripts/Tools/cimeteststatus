#!/usr/bin/env python

from __future__ import print_function
import xml.etree.ElementTree as ET
import xml.dom
import argparse
import os, glob, re
import urllib
import urllib2
import json
import pprint
testdburl = "https://csegwebdev.cgd.ucar.edu/testdb/cgi-bin/processXMLtest.cgi"

class CimeTestStatus():
    # create an enum for the line type
    LINE_TYPE_SEPERATOR = 0
    LINE_TYPE_STATUS = 1
    LINE_TYPE_TIME = 2

    def __init__(self):
        self._status_buffer = None
        self._test_status = {}
        self._current_section = None
    def __repr__(self):
        return pprint.pformat(self._test_status)
    
    def parse(self, filename):
        """Parse the TestStatus file and turn it and save data into the object
        so it can be serialized
        """
        self._buffer_file(filename)
        if self._status_buffer:
            self._extract_test_name()
            self._parse_teststatus() 


    def _buffer_file(self, filename):
        """Read the TestStatus file into a buffer
        """
        with open(filename, 'r') as status:
            self._status_buffer = status.readlines()
        self._raw_status = "".join(self._status_buffer)

    def _parse_teststatus(self):
        """Parse TestStatus files, extracting useful information and saving in
        a dict.
        """
        for line in self._status_buffer:
            line_type = self._determine_line_type(line)
            if line_type is self.LINE_TYPE_SEPERATOR:
                self._parse_seperator(line)
            elif line_type is self.LINE_TYPE_STATUS:
                self._parse_status_line(line)
            elif line_type is self.LINE_TYPE_TIME:
                self._parse_test_time(line)
            else:
                message = ("Unhandled line_type while parsing test status "
                           "file: {0}".format(line_type))
                raise RuntimeError(message)

    def _determine_line_type(self, line):
        """Determine if we are on a test status line or a seperator
        line. Note, the total run time is output on a seperate line....

        """
        line_type = None
        seperator_re = re.compile("^[\s]*---")
        if seperator_re.match(line):
            if "seconds" in line:
                line_type = self.LINE_TYPE_TIME
            else:
                line_type = self.LINE_TYPE_SEPERATOR
        else:
            line_type = self.LINE_TYPE_STATUS

        if line_type is None:
            message = ("Correct line type could not be determined. "
                       "line:\n{0}".format(line))
            raise RuntimeError(message)

        return line_type
    # --------------------------------------------------------------------------
    def _extract_test_name(self):
        """Extract the test name from the buffer. We are assuming that the
        first line of the file will always contain something we can
        use....

        """
        line = self._status_buffer[0]
        name = line.split(' ')[1]
        if len(name.split('.')) > 5:
            name = name.split('.')
            name = name[0:5]
            name = '.'.join(name)
        self._test_status['name'] = name

    # --------------------------------------------------------------------------
    def _parse_seperator(self, line):
        """parse a section seperator to extract the current section name.

        """
        section_re = re.compile("[\s]*---([\w\s]+)---")
        match = section_re.search(line)
        if match:
            self._current_section = match.group(1).strip()
            self._current_section = self._current_section.lower()
            self._test_status[self._current_section] = {}

    # --------------------------------------------------------------------------
    def _parse_test_time(self, line):
        """parse a test time line.

        Note: one of these lines resets the section!
        """
        self._current_section = None
        result = self._extract_test_time(line)
        self._add_result_to_test_status('wall time', result)

    def _extract_test_time(self, line):
        """Extract the test time and units
        """
        test_time = {}
        time_re = re.compile("Test time is ([\d]+) ([\w]+)")
        match = time_re.search(line)
        if match:
            test_time['time'] = match.group(1)
            test_time['units'] = match.group(2)
        else:
            message = ("Coul not extract test time from a time status line:"
                       "\n{0}".format(line))
            raise RuntimeError(message)
        return test_time

    # --------------------------------------------------------------------------
    def _parse_status_line(self, line):
        """parse a status line to extract the useful information.

        Parsing rules:

        1) split on ':'
           the first group is the status, the second (if present) is the comment.
        2) in the first group, split on space ' ':
           the first group is the status, the second is a name field
        """
        split_line = line.split(':')
        status_and_name = split_line[0]
        comment = None
        if len(split_line) > 1:
            comment = split_line[1].strip()

        split_status_and_name = status_and_name.split(' ')
        status = split_status_and_name[0]
        name = None
        if len(split_status_and_name) > 1:
            name = split_status_and_name[1]
        else:
            print(status_and_name)

        test_re = re.compile('test')
        component = None
        section = None
        if comment:
            split_comment = comment.split(' ')
            if ('compare' in comment or 'generate' in comment):
                component = split_comment[2]
            elif test_re.match(comment):
                component = split_comment[2]
            elif 'successful' in comment:
                component = 'status'
        else:
            # we need to extract something from the name field...
            if 'memcomp' in name:
                component = 'memcomp'
            elif 'tputcomp' in name:
                component = 'tputcomp'
            elif 'nlcomp' in name:
                component = 'nlcomp'
                section = "baseline comparison"
            elif 'memleak' in name:
                component = 'memleak'
            else:
                component = 'status'
        if component:
            #print("component ", component, "status ", status, "section ", section)
            self._add_result_to_test_status(component, status, section)

    # --------------------------------------------------------------------------
    def _add_result_to_test_status(self, key, value, section=None):
        """
        """
        use_section = None
        if self._current_section:
            use_section = self._current_section
        elif section:
            use_section = section

        if use_section:
            self._test_status[use_section][key] = value
        else:
            self._test_status[key] = value

    # --------------------------------------------------------------------------
    def as_xml(self):
        """Serialize the test status information as xml
        """
        root = etree.Element('cime_test_status')
        root.set('name', self._test_status['name'])
        root.set('status', self._test_status['status'])
        for name, section in self._test_status.items():
            if isinstance(section, dict):
                elem = etree.Element('section')
                elem.set('name', name)
                for key, value in section.items():
                    child = etree.Element("{0}".format('key'))
                    child.set('name', key)
                    child.text = value
                    elem.append(child)
                root.append(elem)
        return root

    def rawteststatus(self):
        return self._raw_status
    def overallstatus(self):
        return self._test_status['status']
    def histcomparestatus(self):
        if 'test functionality' in self._test_status:
            if 'summary' in self._test_status['test functionality']: 
                return self._test_status['test functionality']['summary']
            else: 
                return None
        else:
            return None
    def baselinecomparestatus(self):
        if 'baseline comparison' in self._test_status:
            if 'summary' in self._test_status['baseline comparison']: 
                return self._test_status['baseline comparison']['summary']
            else: 
                return None
        else:
            return None
    def name(self):
        return self._test_status['name']
    def histcompareline(self):
        return self._test_status['test functionality']['summary'] + " " + self._test_status['name']
    def histcomparefail(self):
        histcomparefails = (self._test_status['name'] + "\n")
        testfunc = self._test_status['test functionality']
        for key in testfunc:
            if key != 'summary' and testfunc[key] == 'FAIL':
                histcomparefails += ( key + " : " )
                histcomparefails += (testfunc[key] + "\n")
        if len(histcomparefails) > 0: 
            return histcomparefails
        else:
            return None
    def baselinecomparefail(self):
        blcomparefail = (self._test_status['name'] + "\n")
        testfunc = self._test_status['baseline comparison']
        for key in testfunc:
            if key != 'summary' and testfunc[key] == 'FAIL':
                blcomparefail += (key + " : " )
                blcomparefail += (testfunc[key] + "\n")
        if len(blcomparefail) > 0:
            return blcomparefail
        else:
            return None
    def baselinecompareline(self):
        return self._test_status['baseline comparison']['summary'] + " " + self._test_status['name']
    #def testStatus(self):
    #    return self.overallstatus +  " " + self.testname  + "\n" + self.output

class CimeTestStatusEncoder(json.JSONEncoder):
    def default(self, obj):
        if isinstance(obj, CimeTestStatus):
            return {"testname" : obj.testname, "status" : obj.overallstatus, "output" : obj.output}
        return json.JSONEncoder.default(self, obj)
        
#------------------------------------------------------------------------------
# Read the test spec, get relevant test info 
#------------------------------------------------------------------------------
def getSuiteInfo(testid):
    
    
    if testid: 
        xmlfile = "testspec." + testid + ".xml"
        print(xmlfile)
    else:
        for file in glob.glob("testspec*xml"):
            xmlfile = file
    
    tree = ET.parse(xmlfile)
    root = tree.getroot()
    suiteinfo = {}
    testlist = []
    
    for tr in root.findall('testroot'):
        suiteinfo['testroot'] = tr.text    
    
    for cr in root.findall('cimeroot'):
        suiteinfo['cimeroot'] = cr.text
    
    for bltag in root.findall('baselinetag'):
        suiteinfo['baselinetag'] = bltag.text
    
    for compiler in root.findall("./testlist/compiler"):
        suiteinfo['compiler'] = compiler.text
    
    for mpilib in root.findall('mpilib'):
        suiteinfo['mpilib'] = mpilib.text
    
    for t in root.findall('test'):
        testlist.append(t.attrib['case'])
    
    suiteinfo['testlist'] = testlist
    return suiteinfo
            
#------------------------------------------------------------------------------
# Get the status of each test
#------------------------------------------------------------------------------
def getTestStatuses(suiteinfo):
    cimetests = []
    for test in suiteinfo['testlist']:
        statusfilename = test + "/TestStatus"
        cimeteststatus = CimeTestStatus()
        cimeteststatus.parse(statusfilename)
        cimetests.append(cimeteststatus)
    return cimetests

def printStatus(cimetests):
    for test in cimetests:
        #print CimeTestStatusEncoder().encode(test)
        print(test.rawteststatus())

def printSummary(suiteinfo, cimetests):
    pass
    #for t in cimetests:
    #    print(cimetests._teststatus['status'], " " , 
    banner = '=' * 80
    
    cfails = [t for t in cimetests if t.overallstatus() == 'CFAIL']
    passes = [t for t in cimetests if t.overallstatus() == 'DONE']
    sfails = [t for t in cimetests if t.overallstatus() == 'SFAIL']
    runs =   [r for r in cimetests if r.overallstatus() == 'RUN' ]
    testcomparefails = [t for t in cimetests if t.histcomparestatus() == 'FAIL']
    baselinecomparefails = [t for t in cimetests if t.baselinecomparestatus() == 'FAIL']
    print(banner)
    print("Test Summary ")
    if passes: 
        print(len(passes), "   Tests passed")
    if testcomparefails:
        print(len(testcomparefails) , "   Tests failed the history file comparison")
    if baselinecomparefails:
        print(len(baselinecomparefails) , "   Tests failed the baseline comparison")
    
    if sfails:
        print(len(sfails), "   Tests had script errors")
    if cfails:
        print(len(cfails), "   Tests had compile fails")
    if runs:
        print(len(runs), "   Tests failed to finish running")
    print(banner)
    
    if testcomparefails:
        print(banner)
        print("The following tests failed the history file comparison:")
        print(banner)
        for t in testcomparefails:
            print(t.histcomparefails())
        print(banner)
    #
    if baselinecomparefails: 
        print(banner)
        print("The following tests failed the baseline comparison:")
        for t in baselinecomparefails:
            #print(t.baselinecompareline())
            print(t.baselinecomparefail())
        print(banner)
    
   
    if passes:
        print(banner)
        print("These tests passed ")
        print(banner)
        for p in passes:
            print(p.name())

    if runs:
        print(banner)
        print("These tests failed to finish running")
        print(banner)
        for r in runs:
            print(r.name())

    if sfails:
        print(banner)
        print("These tests had script errors")
        print(banner)
        for s in sfails:
            print(s.name())

    if cfails:
        print(banner)
        print("These tests failed to compile")
        print(banner)
        for c in cfails:
            print(c.name())
    #for t in cimetests:
    #    print(t)

def cimetestjson(cimetest):
    return cimetest.__dict__

def sendTestReport(suiteinfo, cimetests):
    #print suiteinfo
    suiteinfo.pop("testlist",None)
    #print json.dumps(suiteinfo) 
    #for test in cimetests:
    #    print CimeTestStatusEncoder().encode(test)
    
    username = 'jshollen'
    password = '1vyb3ll$!'

#------------------------------------------------------------------------------
# main function
#------------------------------------------------------------------------------
def main():
    parser = argparse.ArgumentParser(description='cs.status options')

    parser.add_argument('-i', '--testid', help='test id of the particular test suite', required=False)
    parser.add_argument('-s', '--summary', action='store_true', help='Generate summary', required=False)
    parser.add_argument('-t', '--sendtestreport', action='store_true', help='Send the test report to CSEG\'s Test Database', required=False)
    
    args = parser.parse_args()
    #print args
    
    # get info needed to process the test status
    suiteinfo = getSuiteInfo(args.testid)
    
    # Now check each test, get the status of each test. 
    cimetests = getTestStatuses(suiteinfo)
    
    if(args.summary==True):
        printSummary(suiteinfo, cimetests)
    elif(args.sendtestreport==True):
        sendTestReport(suiteinfo, cimetests)
    else:
        printStatus(cimetests)
    
if __name__ == "__main__":
    main()

