#!/usr/bin/env perl 

#-----------------------------------------------------------------------------------------------
#
# manage_compsets
#
# This utility allows the users to manage and query model component sets  
#
#-----------------------------------------------------------------------------------------------

use XML::LibXML;
use IO::File;
use Data::Dumper;
use Getopt::Long;
use POSIX qw(strftime);
use Cwd qw(getcwd abs_path chdir);
use File::Basename;
use strict;

# Check for the existence of XML::LibXML in whatever perl distribution happens to be in use.  
# If not found, print a warning message then exit. 
eval {
    require XML::LibXML;
    XML::LibXML->import();
};
if($@)
{
    my $warning = <<END;
WARNING:
    The perl module XML::LibXML is needed for XML parsing in the CESM script system.  
	Please contact your local systems administrators or IT staff and have them install it for 
	you, or install the module locally.  

END
    print "$warning\n";
    exit(1);
}

#-----------------------------------------------------------------------------------------------
# Setting autoflush (an IO::Handle method) on STDOUT helps in debugging.  It forces the test
# descriptions to be printed to STDOUT before the error messages start.
*STDOUT->autoflush();                  

#-----------------------------------------------------------------------------------------------
# Set the directory that contains the CESM configuration scripts.  If the create_newcase command was
# issued using a relative or absolute path, that path is in $ProgDir.  Otherwise assume the
# command was issued from the current working directory.

(my $ProgName = $0) =~ s!(.*)/!!;      # name of this script
my $ProgDir = $1;                      # name of directory containing this script -- may be a
                                       # relative or absolute path, or null if the script is in
                                       # the user's PATH
my $cwd = getcwd();                    # current working directory
my $cfgdir;                            # absolute pathname of directory that contains this script
if ($ProgDir) { 
    $cfgdir = abs_path($ProgDir);
} else {
    $cfgdir = $cwd;
}

# Set $cimeroot and $srcroot
my $cimeroot = abs_path("$cfgdir/../");
(-d "$cimeroot")  or  die <<"EOF";
** Cannot find cimeroot directory \"$cimeroot\" **
EOF

#TODO - these need to be generalized - machroot needs to be read in from the definitions_files.xml
my $srcroot  = abs_path("$cimeroot/../");
my $file_config = "$cimeroot/scripts/cimeconfig/config_files.xml";

#-----------------------------------------------------------------------------------------------
if ($#ARGV == -1) {
    usage();
}
#-----------------------------------------------------------------------------------------------

sub usage {
    die <<EOF;

SYNOPSIS
  manage_newcase -list  [options]

OPTIONS
  User supplied values are denoted in angle brackets (<>).  Any value that contains
  white-space must be quoted.  Long option names may be supplied with either single
  or double leading dashes.  A consequence of this is that single letter options may
  NOT be bundled.

  -list compsets    -compsets_setby [cam, clm, cice, cism, pop, allactive] (if model is CESM)
  -list definitions -component      [cam, clm, cice, cism, pop, datm, dlnd, dice, dglc, docn] (if model is CESM)
  -list grids
  -list machines

EOF
}

#-----------------------------------------------------------------------------------------------
# Save commandline
my $commandline = "create_newcase @ARGV";

#-----------------------------------------------------------------------------------------------
# Parse command-line options.
my %opts = ( );
GetOptions(
    "h|help"            => \$opts{'help'},
    "list=s"            => \$opts{'list'},
    "grids=s"           => \$opts{'grids'},
    "machines=s"        => \$opts{'machines'},
    "compsets_setby=s"  => \$opts{'compsets_setby'},
    "component=s"       => \$opts{'component'},
    "v|verbose"         => \$opts{'verbose'},
    )  or usage();

# Give usage message.
usage() if $opts{'help'};

# Check for unparsed argumentss
if (@ARGV) {
    print "ERROR: unrecognized arguments: @ARGV\n";
    usage();
}

#-----------------------------------------------------------------------------------------------
# Add $cfgdir/perl5lib to the list of paths that Perl searches for modules
my @dirs = ("$cimeroot/scripts/Tools");
unshift @INC, @dirs;
require ConfigMachine;

my $xml = XML::LibXML->new( no_blanks => 1)->parse_file("$file_config");

my $compsets_setby;
if ($opts{'list'} eq 'definitions') {
    if (! $opts{'component'}) {
	die "ERROR: must also specify an input argument,  -component <ANY component name> \n";
    } else {
	$compsets_setby = $opts{'component'};
    }
}
if ($opts{'list'} eq "compsets") {
    if (! $opts{'compsets_setby'}) {
	die "ERROR: must also specify an input argument,  -compsets_setby <primary component name>\n";
    }
}

my $list_option = $opts{'list'};
if ($list_option eq "compsets") 
{
    my @files = $xml->findnodes(".//entry[\@id=\"COMPSETS_SPEC_FILE\"]/values/value[\@component=\"$opts{'compsets_setby'}\"]");
    if (! @files) {
	die " ERROR: no compsets specification file found for  $compsets_setby \n";
    }
    my $file = $files[0]->textContent();
    $file =~ s/\$CIMEROOT/$cimeroot/;
    $file =~ s/\$SRCROOT/$srcroot/;
    (-f "$file")  or  die "*** Cannot find compsets specification file $file ***\n";
    _listCompsets($file);
} 
elsif ($list_option eq "definitions") 
{
    my $xml = XML::LibXML->new( no_blanks => 1)->parse_file($file_config);
    my @files = $xml->findnodes(".//entry[\@id[contains(.,\"CONFIG\")]]/values/value[\@component=\"$opts{'component'}\"]");
    if (! @files) {
	die " ERROR: no component definition files found for component $compsets_setby \n";
    }
    my $file = $files[0]->textContent();
    $file =~ s/\$CIMEROOT/$cimeroot/;
    $file =~ s/\$SRCROOT/$srcroot/;
    (-f $file) or die "ERROR: component definition file $file is not present"; 
    _listComponentDefinitions($file);
} 
elsif ($list_option eq "grids") 
{
    my @dirs = $xml->findnodes(".//entry[\@id=\"GRIDS_DIR\"]/value");
    if (! @dirs) {
	die " ERROR: in parsing $file_config for the GRID_DIR node \n";
    }
    my $grids_dir = $dirs[0]->textContent();
    $grids_dir =~ s/\$CIMEROOT/$cimeroot/;
    $grids_dir =~ s/\$SRCROOT/$srcroot/;
    (-d "$grids_dir")  or  die "** Cannot find grids dir $grids_dir ***\n";
    my $grids_file = "$grids_dir" . '/' . "config_grids.xml";
    _listGrids($grids_file);
} 
elsif ($list_option eq "machines") 
{
    my @files = $xml->findnodes(".//entry[\@id=\"MACHINES_SPEC_FILE\"]/value");
    if (! @files) {
	die " ERROR: in parsing $file_config for the MACHINES_SPEC_FILE node \n";
    }
    my $file = $files[0]->textContent();
    $file =~ s/\$CIMEROOT/$cimeroot/;
    $file =~ s/\$SRCROOT/$srcroot/;
    (-f $file) or die "ERROR: machines specification file $file is not present"; 
    ConfigMachine::listMachines($file);
} 
else 
{
    print "** Bad argument to the list option: $list_option \n";
    print "** Valid options: compsets, grids or machines ** \n";
    die;
}
print "finished listing valid values, now exiting \n";
exit 0;


#-----------------------------------------------------------------------------------------------
#                               Private routines
#-----------------------------------------------------------------------------------------------
sub _listCompsets
{
    # List the supported compsets for the primary component
    my ($compsets_file) = @_;

    my $xml = XML::LibXML->new(no_blanks => 1)->parse_file($compsets_file);

    print "     =============================================================\n";
    print "     The following are the supported components sets in the file \n";
    print "     $compsets_file \n";
    print "     =============================================================\n";

    print " \n";
    foreach my $node ($xml->findnodes(".//help")) {
	my $help = $node->textContent();
	print "$help \n\n";
    }

    foreach my $node ($xml->findnodes(".//COMPSET")) {
	my @lname_node = $node->findnodes("./lname");
	my @alias_node = $node->findnodes("./alias");
	my @support_node = $node->findnodes("./support_level");

	my $lname   = $lname_node[0]->textContent;
	my $alias   = $alias_node[0]->textContent;
	my $grid    = $node->getAttribute('grid');
	my $support;
	if (@support_node)  {$support = $support_node[0]->textContent;}

	printf("     alias: %-25s longname: %-96s \n",$alias,$lname);
        if ( $grid) {
        printf("                                                grid match:  %-96s \n", $grid );
        }
        if ($support) {
        printf("                                                support level    :  %-96s \n", $support );
        }
    }    
    print "\n";
}

#-----------------------------------------------------------------------------------------------
sub _listComponentDefinitions
{
    my ($compsets_file) = @_;
 
    my $xml = XML::LibXML->new( no_blanks => 1)->parse_file($compsets_file);
    foreach my $node ($xml->findnodes("//help")) {
	my $value = $node->textContent();
	print"     $value \n"; 
    }
    foreach my $node ($xml->findnodes("//description/*")) {
	my $attr  = $node->getAttribute('compset');
	my $value = $node->textContent();
	printf("    %-25s => %-96s \n",$attr,$value);
    }
    print "\n";
}

#-------------------------------------------------------------------------------
sub _listGrids
{
    # Print all currently supported valid grids
    my ($grids_file) = @_;

    my $xml = XML::LibXML->new( no_blanks => 1)->parse_file($grids_file);

    print " \n";
    foreach my $node ($xml->findnodes(".//help")) {
	my $help = $node->textContent();
	print "$help \n\n";
    }

    print "\n";
    print " ======================================================\n";
    print "                Component Grids:                       \n";
    print " ======================================================\n";
    print "\n";
    foreach my $node ($xml->findnodes(".//domain")) {
	my $name  = $node->getAttribute('name');
	my $alias = $node->getAttribute('alias');
	if ($alias) { 
	    print " component grid: $name (alias: $alias) \n";
	} else {
	    print " component grid: $name \n";
	}	    
	my $support_level; my $nx; my $ny; my $desc;
	foreach my $child_node ($node->childNodes()) {
	    my $name  = $child_node->nodeName();
	    my $value = $child_node->textContent();
	    if ($name eq 'support_level') {$support_level= $value;}
	    if ($name eq 'nx') {$nx = $value;}
	    if ($name eq 'ny') {$ny = $value;}
	    if ($name eq 'desc') {$desc = $value;}
	}
	if (defined $desc)           {print "   $desc \n";}
	if (defined $nx  )           {print "   nx: $nx ny: $ny \n";}
	if (defined $support_level ) {print "   support_level: support_level \n";}
	print " \n";
    }

    print "\n";
    print " ======================================================\n";
    print "                Model Grids:                           \n";
    print " ======================================================\n";
    print "\n";
    foreach my $node ($xml->findnodes(".//GRID")) {
	my $alias         = $node->getAttribute('alias');
	my $compset       = $node->getAttribute('compset');
	my $support_level = $node->getAttribute('support_level');
	my $lname         = $node->textContent();
	print " model grid: $lname \n";
	if (defined ($alias)  )       { print "    alias        : $alias \n"}
	if (defined ($compset))       { print "    compset match: $compset \n"}
	if (defined ($support_level)) { print "    support_level: $support_level \n";}
	print " \n";
    }    
    print " \n";
}
