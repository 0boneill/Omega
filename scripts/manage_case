#!/usr/bin/env perl 

#-----------------------------------------------------------------------------------------------
#
# manage_compsets
#
# This utility allows the users to manage and query model component sets  
#
#-----------------------------------------------------------------------------------------------

use XML::LibXML;
use IO::File;
use Data::Dumper;
use Getopt::Long;
use POSIX qw(strftime);
use Cwd qw(getcwd abs_path chdir);
use File::Basename;
use strict;

# Check for the existence of XML::LibXML in whatever perl distribution happens to be in use.  
# If not found, print a warning message then exit. 
eval {
    require XML::LibXML;
    XML::LibXML->import();
};
if($@)
{
    my $warning = <<END;
WARNING:
    The perl module XML::LibXML is needed for XML parsing in the CESM script system.  
	Please contact your local systems administrators or IT staff and have them install it for 
	you, or install the module locally.  

END
    print "$warning\n";
    exit(1);
}

#-----------------------------------------------------------------------------------------------
# Setting autoflush (an IO::Handle method) on STDOUT helps in debugging.  It forces the test
# descriptions to be printed to STDOUT before the error messages start.
*STDOUT->autoflush();                  

#-----------------------------------------------------------------------------------------------
# Set the directory that contains the CESM configuration scripts.  If the create_newcase command was
# issued using a relative or absolute path, that path is in $ProgDir.  Otherwise assume the
# command was issued from the current working directory.

(my $ProgName = $0) =~ s!(.*)/!!;      # name of this script
my $ProgDir = $1;                      # name of directory containing this script -- may be a
                                       # relative or absolute path, or null if the script is in
                                       # the user's PATH
my $cwd = getcwd();                    # current working directory
my $cfgdir;                            # absolute pathname of directory that contains this script
if ($ProgDir) { 
    $cfgdir = abs_path($ProgDir);
} else {
    $cfgdir = $cwd;
}

#-----------------------------------------------------------------------------------------------
if ($#ARGV == -1) {
    usage();
}
#-----------------------------------------------------------------------------------------------

sub usage {
    die <<EOF;

SYNOPSIS
  manage_case -model [options] -query  [options]

OPTIONS
  User supplied values are denoted in angle brackets (<>).  Any value that contains
  white-space must be quoted.  Long option names may be supplied with either single
  or double leading dashes.  A consequence of this is that single letter options may
  NOT be bundled.

  -model [cesm, acme]
  -query compsets -setby [cam, clm, cice, cism, pop, allactive] (if model is CESM)
  -query component -name [cam, clm, cice, cism, pop, datm, dlnd, dice, dglc, docn] (if model is CESM)
  -query grids
  -query machines

EOF
}

#-----------------------------------------------------------------------------------------------
# Save commandline
my $commandline = "create_newcase @ARGV";

#-----------------------------------------------------------------------------------------------
# Parse command-line options.
my %opts = ( );
GetOptions(
    "h|help"            => \$opts{'help'},
    "query=s"           => \$opts{'query'},
    "model=s"           => \$opts{'model'},
    "setby=s"		=> \$opts{'setby'},
    "name=s"            => \$opts{'name'},
    "v|verbose"         => \$opts{'verbose'},
    )  or usage();

# Give usage message.
usage() if $opts{'help'};

# Check for unparsed argumentss
if (@ARGV) {
    print "ERROR: unrecognized arguments: @ARGV\n";
    usage();
}

#-----------------------------------------------------------------------------------------------
# Set $cimeroot and $srcroot
my $cimeroot = abs_path("$cfgdir/../");
(-d "$cimeroot")  or  die <<"EOF";
** Cannot find cimeroot directory \"$cimeroot\" **
EOF
my $srcroot  = abs_path("$cimeroot/../");
(-d "$srcroot")  or  die <<"EOF";
** Cannot find srcroot directory \"$srcroot\" **
EOF


my $model_option = $opts{'model'};
if (! $opts{'model'}) {
    die "ERROR: must specify model argument \n";
}

my $query_option = $opts{'query'};
if (! $opts{'model'}) {
    die "ERROR: must specify query argument \n";
}

my $file_config = "$cimeroot/cime_config/${model_option}/config_files.xml";
(-f "$file_config")  or  die "*** Cannot find model specification file $file_config ***\n\n";
my $xml = XML::LibXML->new( no_blanks => 1)->parse_file("$file_config");

if ($query_option eq "compsets") 
{
    if (! $opts{'setby'}) {
	print "ERROR: The $model_option components and associated files that specify model compsets are \n";
	my @components = $xml->findnodes(".//entry[\@id=\"COMPSETS_SPEC_FILE\"]/values/value");
	foreach my $component (@components) {
	    my $attr = $component->getAttribute('component'); 
	    my $file = $component->textContent();
	    $file =~ s/\$CIMEROOT/$cimeroot/;
	    $file =~ s/\$SRCROOT/$srcroot/;
	    printf("   %-10s %-50s \n",$attr, $file );
	}
	print "Must use one of the above components in the -setby <component> argument \n";
	die; 
    }
    my @files = $xml->findnodes(".//entry[\@id=\"COMPSETS_SPEC_FILE\"]/values/value[\@component=\"$opts{'setby'}\"]");
    if (! @files) {
	die " ERROR: no compsets specification file found for  $opts{'setby'} \n";
    }
    my $file = $files[0]->textContent();
    $file =~ s/\$CIMEROOT/$cimeroot/;
    $file =~ s/\$SRCROOT/$srcroot/;
    (-f "$file")  or  die "*** Cannot find compsets specification file $file ***\n\n";
    _queryCompsets($file);
} 
elsif ($query_option eq "component") 
{
    if (! $opts{'name'}) {
	die "ERROR: must also specify an input argument,  -name <component name>\n";
    }
    my $xml = XML::LibXML->new( no_blanks => 1)->parse_file($file_config);
    my @files = $xml->findnodes(".//entry[\@id[contains(.,\"CONFIG\")]]/values/value[\@component=\"$opts{'name'}\"]");
    if (! @files) {
	die " ERROR: no component config_component.xml files found for component $opts{'setby'} \n";
    }
    my $file = $files[0]->textContent();
    $file =~ s/\$CIMEROOT/$cimeroot/;
    $file =~ s/\$SRCROOT/$srcroot/;
    (-f $file) or die "ERROR: component definition file $file is not present"; 
    _queryComponent($file);
} 
elsif ($query_option eq "grids") 
{
    my @dirs = $xml->findnodes(".//entry[\@id=\"GRIDS_DIR\"]/value");
    if (! @dirs) {
	die " ERROR: in parsing $file_config for the GRID_DIR node \n";
    }
    my $grids_dir = $dirs[0]->textContent();
    $grids_dir =~ s/\$CIMEROOT/$cimeroot/;
    $grids_dir =~ s/\$SRCROOT/$srcroot/;
    (-d "$grids_dir")  or  die "** Cannot find grids dir $grids_dir ***\n";
    my $file = "$grids_dir" . '/' . "config_grids.xml";
    _queryGrids($file);
} 
elsif ($query_option eq "machines") 
{
    my @files = $xml->findnodes(".//entry[\@id=\"MACHINES_SPEC_FILE\"]/value");
    if (! @files) {
	die " ERROR: in parsing $file_config for the MACHINES_SPEC_FILE node \n";
    }
    my $file = $files[0]->textContent();
    $file =~ s/\$CIMEROOT/$cimeroot/;
    $file =~ s/\$SRCROOT/$srcroot/;
    (-f $file) or die "ERROR: machines specification file $file is not present"; 

    unshift @INC, "$cimeroot/utils/perl5lib";
    require Config::ConfigMachine;
    ConfigMachine::queryMachines($file);
} 
else 
{
    print "** Bad argument to the query option: $query_option \n";
    print "** Valid options: compsets, component, grids or machines ** \n";
    die;
}
print "finished querying valid values, now exiting \n";
exit 0;


#-----------------------------------------------------------------------------------------------
#                               Private routines
#-----------------------------------------------------------------------------------------------
sub _queryCompsets
{
    # Query the supported compsets for the primary component
    my ($file) = @_;

    my $xml = XML::LibXML->new(no_blanks => 1)->parse_file($file);

    print " =============================================================\n";
    print " The following are the supported components sets in the file \n";
    print " $file \n";
    print " =============================================================\n";

    print " \n";
    foreach my $node ($xml->findnodes(".//help")) {
	my $help = $node->textContent();
	print "$help \n\n";
    }

    foreach my $node ($xml->findnodes(".//compset")) {
	my $grid     = $node->getAttribute('grid');
	my @lnames   = $node->findnodes("./lname");
	my @aliases  = $node->findnodes("./alias");
	my @supports = $node->findnodes("./support");

	my $lname   = $lnames[0]->textContent;
	my $alias   = $aliases[0]->textContent;
	my $support;
	if ($#supports > -1)  {
	    $support = $supports[0]->textContent;
	}
	printf("     alias: %-25s longname: %-96s \n",$alias,$lname);
        if ( $grid) {
        printf("                                                grid match:  %-96s \n", $grid );
        }
        if ($support) {
        printf("                                                support level    :  %-96s \n", $support );
        }
    }    
    print "\n";
}

#-----------------------------------------------------------------------------------------------
sub _queryComponent
{
    my ($file) = @_;
 
    my $xml = XML::LibXML->new( no_blanks => 1)->parse_file($file);
    foreach my $node ($xml->findnodes("//help")) {
	my $value = $node->textContent();
	print"     $value \n"; 
    }
    foreach my $node ($xml->findnodes("//description/*")) {
	my $attr  = $node->getAttribute('compset');
	my $value = $node->textContent();
	printf("    %-25s => %-96s \n",$attr,$value);
    }
    print "\n";
}

#-------------------------------------------------------------------------------
sub _queryGrids
{
    # Print all currently supported valid grids
    my ($file) = @_;

    my $xml = XML::LibXML->new( no_blanks => 1)->parse_file($file);

    print " \n";
    foreach my $node ($xml->findnodes(".//help")) {
	my $help = $node->textContent();
	print "$help \n\n";
    }

    print "\n";
    print " ======================================================\n";
    print "                Component Grids:                       \n";
    print " ======================================================\n";
    print "\n";
    foreach my $node ($xml->findnodes(".//domains/domain")) {
	my $name  = $node->getAttribute('name');
	my $alias = $node->getAttribute('alias');
	if ($alias) { 
	    print " component grid: $name (alias: $alias) \n";
	} else {
	    print " component grid: $name \n";
	}	    
	my $support; my $nx; my $ny; my $desc;
	foreach my $child_node ($node->childNodes()) {
	    my $name  = $child_node->nodeName();
	    my $value = $child_node->textContent();
	    if ($name eq 'support') {$support= $value;}
	    if ($name eq 'nx') {$nx = $value;}
	    if ($name eq 'ny') {$ny = $value;}
	    if ($name eq 'desc') {$desc = $value;}
	}
	if (defined $desc)    {print "   $desc \n";}
	if (defined $nx  )    {print "   nx: $nx ny: $ny \n";}
	if (defined $support) {print "   support_level: support_level \n";}
	print " \n";
    }

    print "\n";
    print " ======================================================\n";
    print "                Model Grids:                           \n";
    print " ======================================================\n";
    print "\n";
    foreach my $node ($xml->findnodes(".//grids/grid")) {
	my $alias     = $node->getAttribute('alias');
	my $compset   = $node->getAttribute('compset');
	my $support   = $node->getAttribute('support');
	my $lname     = $node->textContent();
	print " model grid: $lname \n";
	if (defined ($alias)  ) { print "    alias        : $alias \n"}
	if (defined ($compset)) { print "    compset match: $compset \n"}
	if (defined ($support)) { print "    support level: $support \n";}
	print " \n";
    }    
    print " \n";
}
